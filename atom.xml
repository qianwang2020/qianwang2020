<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.qianqian.fun</id>
    <title>汪小白的博客</title>
    <updated>2020-09-08T09:18:34.545Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.qianqian.fun"/>
    <link rel="self" href="https://blog.qianqian.fun/atom.xml"/>
    <subtitle>用勤劳的双手换取想要的生活</subtitle>
    <logo>https://blog.qianqian.fun/images/avatar.png</logo>
    <icon>https://blog.qianqian.fun/favicon.ico</icon>
    <rights>All rights reserved 2020, 汪小白的博客</rights>
    <entry>
        <title type="html"><![CDATA[Python环境的搭建]]></title>
        <id>https://blog.qianqian.fun/post/python-huan-jing-de-da-jian/</id>
        <link href="https://blog.qianqian.fun/post/python-huan-jing-de-da-jian/">
        </link>
        <updated>2020-09-03T09:03:59.000Z</updated>
        <content type="html"><![CDATA[<p>本文就 python 开发环境的安装配置做一些说明。</p>
<h2 id="python-版本的选择">Python 版本的选择</h2>
<p>Python 采用了两段式的版本号 <code>&lt;Main&gt;.&lt;Subject&gt;</code> , 比如当前最新版本是 3.8。大的版本号分为 2.X 和 3.X。没有例外，应该全部选择 3.X 版本，2.X 已经走入了历史。</p>
<p>在 3.X 的众多版本中，其增加了如下的特性:</p>
<h2 id="python-30">Python 3.0</h2>
<p>• 函数注解（ Function Annotations ），可以对函数的参数和返回值进行注解。除了可以通过 <code>__annotations__</code>来访问这些注解外，没有其他更多的语义；<br>
• 仅限关键字形参（ Keyword-only arguments ），在函数形参中使用 <code>*</code> 来表示对应的形参必须使用关键字进行传递；<br>
• <code>nonlocal</code> 语句允许嵌套函数中的内部函数对外层函数作用域中的变量进行赋值；<br>
• 扩展的 Iterable 解包，比如 <code>(a, *rest, b) = range(5)；</code>；<br>
• 集合字面量，字典推导，新的八进制字面量，以 <code>b</code> 或 <code>B</code> 开头的字节串等等；</p>
<h2 id="python-31">Python 3.1</h2>
<p>• 有序字典 <code>collections.OrderedDict</code>；<br>
• 千位分隔符的格式说明符，比如 <code>'{0:,d}'.format(1234567) —&gt; '1,234,567'</code>；</p>
<h2 id="python-32">Python 3.2</h2>
<p>• Argparse 命令行解析模块；<br>
• 基于字典的日志配置 <code>logging.config.dictConfig()</code> 可以支持更灵活的配置方式；<br>
• concurrent.futures 模块 ；<br>
• 将字节码文件单独存储在 <code>__pycache__</code> 目录；</p>
<h2 id="python-33">Python 3.3</h2>
<p>• 虚拟环境工具 venv 和 pyvenv，后者 pyvenv 在 Python 3.6 中已弃用；<br>
• 隐式命名空间包；<br>
• OS 和 IO 异常的层次结构优化；<br>
• 委托给子生成器 <code>yield from</code>；<br>
• 允许禁用链式异常上下文的显示从而获取更干净的错误消息，比如 <code>raise AttributeError(attr) from None</code>；</p>
<h2 id="python-34">Python 3.4</h2>
<p>• pip 默认包含在 Python 的二进制安装程序中；<br>
• 异步 I/O 库 asyncio；<br>
• 支持枚举的模块 enum；<br>
• 面向对象的文件系统路径模块 pathlib；<br>
• 高级 I/O 复用模块 selectors；<br>
• 用于数学统计的模块 statistics；</p>
<h2 id="python-35">Python 3.5</h2>
<p>• 使用 async 和 await 语法实现原生协程 ；<br>
• 矩阵乘法运算符 <code>a @ b</code> ；<br>
• 类型标注支持的模块 <code>typing</code>；<br>
• 进一步扩展带有 <code>*</code> 的可迭代对象解包操作和带有 <code>**</code> 的字典解包操作；</p>
<h2 id="python-36">Python 3.6</h2>
<p>• 文字字符串插值，比如 <code>f&quot;He said his name is {name}.</code>&quot;；<br>
• 用于进一步增强类型标注的变量注释语法，比如 <code>names: List[str] = []</code>；<br>
• 异步生成器，允许在 <code>async / await</code> 中使用 <code>yield</code>；<br>
• 使用 <code>async for</code> 进行异步推导；<br>
• 用于生成高加密强度的随机数、密码、安全凭证的模块 <code>secrets</code>；</p>
<h2 id="python-37">Python 3.7</h2>
<p>• 延迟的类型标注求值；<br>
• 用于 Python 调试的内置 <code>breakpoint()</code> 函数；<br>
• 用于支持上下文变量的 <code>contextvars</code> 模块；<br>
• 声明数据类的 <code>dataclass()</code>，比如：</p>
<pre><code>@dataclass
class Person:
    name: str
    height: float
    weight: float = 130.0
p = Point('Bob', 175.5)
print(p)   # 输出 &quot;Person(name=Bob, y=175.5, z=130.0)&quot;
</code></pre>
<h2 id="python-38">Python 3.8</h2>
<p>• 赋值表达式语法 <code>:=</code>；<br>
• 仅限位置形参（ Positional-only parameters ），在函数形参中使用 <code>/</code> 来表示对应的形参必须使用位置进行传递。</p>
<h2 id="pip-的使用">Pip 的使用</h2>
<p>pip 是 Python 自带的一个包管理的工具，可以使用对项目中的依赖进行管理。就其基础的使用，如下实例:</p>
<pre><code>pip install &lt;package&gt; [package...]    ## 安装一个多多个包
pip install &lt;package&gt;==2.21.0         ## 安装指定版本的包
pip install --upgrade &lt;package&gt;       ## 升级指定的包
pip uninstall &lt;package&gt;               ## 卸载指定的包
pip list                              ## 打印已经安装的包的列表
pip freeze &gt; requirements.txt         ## 生成已经安装的软件包的列表，并重定向到 requirements.txt 文件中
pip install -r requirements.txt       ## 根据 requirements.txt 文件中的内容安装项目所需依赖
</code></pre>
<p>如果在使用 pip 的过程中出现安装超时的现象，可能是因为国外服务器在国内不稳定的缘故，可以换成豆瓣的镜像服务器下载资源，这样会快很多。编辑配置文件 <code>~/.pip/pip.conf</code> ， 内容如下:</p>
<pre><code>[global]
index-url = https://pypi.doubanio.com/simple
trusted-host = pypi.doubanio.com
</code></pre>
<h2 id="jupyter-notebooks">Jupyter Notebooks</h2>
<p>首先安装 Anaconda， 在其官方页面上下载安装包安装即可。安装的过程中，建议勾选，将可执行文件加入 PATH 的选项。</p>
<p>在 Anaconda 中已经包含了 Jupyter Notebooks ，直接在命令行下运行即可:</p>
<pre><code>jupyter notebook
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[终端复用器：tmux]]></title>
        <id>https://blog.qianqian.fun/post/zhong-duan-fu-yong-qi-tmux/</id>
        <link href="https://blog.qianqian.fun/post/zhong-duan-fu-yong-qi-tmux/">
        </link>
        <updated>2020-09-01T08:20:38.000Z</updated>
        <content type="html"><![CDATA[<p>使用 Linux，我们绝大多数的时候看到的都是黑漆漆的画面，是有一些枯燥的。但是，能不能在枯燥的画面中，玩些花样呢？<br>
比如说，我们模拟一个多窗口的环境，可以在多个窗口之间切换。再比如说，模拟一个多桌面的环境，不同的桌面包含不同的窗口。<br>
要实现上面这些功能，我们就需要清楚这篇文章的主角了 —— tmux。</p>
<h2 id="安装-tmux">安装 tmux</h2>
<p>如果是 CentOS：</p>
<pre><code>$ sudo yum install tmux
</code></pre>
<p>如果是 macOS:</p>
<pre><code>$ brew install tmux
</code></pre>
<h2 id="创建和销毁会话">创建和销毁会话</h2>
<p>在 tmux 中，有一个 Session 的概念，和桌面是一样的意思。一个 Session 可以包含多个窗口( Window ）。如何创建 Session 呢？</p>
<pre><code>$ tmux new -s &lt;Session Name&gt;
</code></pre>
<p>查看已经创建的 Session：</p>
<pre><code>$ tmux ls
</code></pre>
<p>进入已经创建的 Session：</p>
<pre><code>$ tmux a -t &lt;Session Name&gt;
</code></pre>
<p>如果要临时退出会话, 使用 <code>ctrl+b</code> ，然后按下 <code>d</code> 。<br>
如果要销毁会话，使用 <code>ctrl+b</code> ，然后按下 <code>:</code> 进入命令模式，输入命令: <code>kill-session</code> 。</p>
<h2 id="模拟多窗口的环境">模拟多窗口的环境</h2>
<p>窗口是基于 Session 的，所以需要先进入一个 Session。然后创建窗口，需要使用 <code>Ctrl + b</code> , 然后按下  <code>c</code> 键:<br>
<img src="https://blog.qianqian.fun/post-images/1599553600554.png" alt="" loading="lazy"><br>
我们看到下面显示着一行绿色的状态栏，内容如下:<br>
<img src="https://blog.qianqian.fun/post-images/1599553606953.png" alt="" loading="lazy"><br>
你看到上面切换的窗口序号了吗？我们可以根据这个切换窗口，比如要切换到第一个窗口，就可以按下组合键: <code>Ctrl + b</code> , 然后按下 <code>1</code> ，这里的 <code>1</code> 就是窗口的序号。<br>
我们看到，起 Window 的默认命令规则是采用了命令提示符，如果要重命名呢？ <code>Ctrl+B</code> ,然后按下 <code>,</code> 。<br>
如果我们要暂停这个会话，回到最初的界面呢？ <code>Ctrl + B</code> ，然后按下 <code>d</code> 。</p>
<h2 id="分割窗口">分割窗口</h2>
<p>一个窗口可以切换成多个 Pane(面板)。使用 <code>Ctrl+B</code> ，然后按下 <code>&quot;</code> 可以创建水平面板，按下 <code>%</code> 可以创建垂直面板。<br>
如果需要切换全屏，可以使用 <code>Ctrl+B</code> ,然后按下 <code>z</code> 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux常用的命令-文件和磁盘]]></title>
        <id>https://blog.qianqian.fun/post/linux-chang-yong-de-ming-ling-wen-jian-he-ci-pan/</id>
        <link href="https://blog.qianqian.fun/post/linux-chang-yong-de-ming-ling-wen-jian-he-ci-pan/">
        </link>
        <updated>2020-08-20T07:57:09.000Z</updated>
        <content type="html"><![CDATA[<p>这一篇文档记录了一些有关于文件和磁盘的命令。</p>
<h2 id="linux-文件系统">Linux 文件系统</h2>
<p>在了解这些命令之前，我们需要先了解 Linux 文件系统。在 Windows 中，我们的磁盘会被划分为多个逻辑磁盘:<br>
<img src="https://blog.qianqian.fun/post-images/1599553062832.png" alt="" loading="lazy"><br>
但是在 Linux 上，和 Windows 是完全不一样，没有 A盘、B盘、C盘的概念，有的只是一棵目录树。<br>
<img src="https://blog.qianqian.fun/post-images/1599553021390.jpg" alt="" loading="lazy"><br>
那么这么多的目录他们都是干什么用的呢？下面这张表格可以回答这个问题:</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>bin</td>
<td>重要的可执行文件、shell 命令</td>
</tr>
<tr>
<td>boot</td>
<td>引导器配置文件、内核等</td>
</tr>
<tr>
<td>dev</td>
<td>设备文件</td>
</tr>
<tr>
<td>etc</td>
<td>系统专有的配置文件</td>
</tr>
<tr>
<td>lib</td>
<td>重要的共享库和内核模块</td>
</tr>
<tr>
<td>media</td>
<td>可移动设备挂载点</td>
</tr>
<tr>
<td>mnt</td>
<td>其他文件系统的临时挂载点</td>
</tr>
<tr>
<td>opt</td>
<td>附加应用软件包</td>
</tr>
<tr>
<td>sbin</td>
<td>重要的系统可执行文件</td>
</tr>
<tr>
<td>tmp</td>
<td>临时文件</td>
</tr>
<tr>
<td>usr</td>
<td>文件系统的第三层</td>
</tr>
<tr>
<td>var</td>
<td>可变数据</td>
</tr>
</tbody>
</table>
<h2 id="find-查找文件">find-查找文件</h2>
<p>比如我们需要查找名为 <code>passwd</code> 的文件:</p>
<pre><code>$ sudo find / -name passwd   ## 对应的格式： find [path...] -name [pattern]
</code></pre>
<p>我们可以指定文件类型，比如说指定为目录:</p>
<pre><code>$ sudo find / -type d -name etc
/sys/firmware/qemu_fw_cfg/by_name/etc
/etc
...省略
</code></pre>
<p>文件的类型如下表所示:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>文件夹</td>
</tr>
<tr>
<td>f</td>
<td>普通文件</td>
</tr>
<tr>
<td>l</td>
<td>符号连接文件</td>
</tr>
<tr>
<td>b</td>
<td>块设备</td>
</tr>
<tr>
<td>c</td>
<td>字符设备</td>
</tr>
<tr>
<td>p</td>
<td>管道文件</td>
</tr>
<tr>
<td>s</td>
<td>socket 套接字</td>
</tr>
</tbody>
</table>
<p>命令当中也可以指定通配符, 比如我要搜索 <code>.jpg</code> 结尾的文件:</p>
<pre><code>$ sudo find / -name '*.jpg'
/usr/share/backgrounds/morning.jpg
/usr/share/backgrounds/night.jpg
...省略
</code></pre>
<p>我们还可以按照文件的大小来搜索:</p>
<pre><code>$ sudo find / -type f -size +40M
/var/lib/rpm/Packages
/usr/lib/locale/locale-archive
/usr/local/sgd/ags/monitor/log/INFO.log
...省略
</code></pre>
<h2 id="du和df-磁盘占用">du和df-磁盘占用</h2>
<p>du 命令，全称是 disk usage, 用来展示磁盘使用量的统计信息。</p>
<pre><code>## 统计当前目录下的磁盘占用
## s 表示每一个给定的参数计算其磁盘使用量
## h 表示使用人类可以阅读的单位显示，比如 KB\MB\GB
$ du -sh .     
</code></pre>
<p>df 命令, 侧重在文件系统级别的磁盘占用，而 du 则是测试中在文件夹和文件的磁盘占用。</p>
<pre><code>$ df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/vda1        40G  2.2G   38G   6% /
devtmpfs        1.9G     0  1.9G   0% /dev
tmpfs           1.9G     0  1.9G   0% /dev/shm
tmpfs           1.9G   33M  1.9G   2% /run
...省略
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[近期学习的Linux命令]]></title>
        <id>https://blog.qianqian.fun/post/jin-qi-xue-xi-de-linux-ming-ling/</id>
        <link href="https://blog.qianqian.fun/post/jin-qi-xue-xi-de-linux-ming-ling/">
        </link>
        <updated>2020-07-25T08:18:36.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>mkdir 创建文件夹<br>
<code>mkdir aa</code></li>
<li>touch 创建文件<br>
<code>touch a.txt</code></li>
<li>cd 切换目录<br>
<code>cd home</code><br>
<code>cd /</code><br>
<code>cd ~</code></li>
<li>cat 查看文件内容<br>
<code>cat a.txt</code></li>
<li>登陆服务器<br>
<code>ssh root@47.100.18.25</code></li>
<li>tail 查看文件尾部内容<br>
<code>tail -n1 /etc/passwd</code></li>
<li>ls 显示指定工作目录下的内容及属性信息<br>
<code>sudo ls -al /etc/skel</code><br>
-a	显示所有文件及目录 (包括以“.”开头的隐藏文件)<br>
-l	使用长格式列出文件及目录信息</li>
<li>echo 输出字符串或提取Shell变量的值<br>
<code>echo '' alias CD_TEST='cd ~/test' &quot; &gt;&gt; ~/.bashrc</code><br>
追加内容  alias CD_TEST='cd ~/test'  到bashrc中</li>
<li>alias 设置命令别名<br>
<code>alias -p</code><br>
查看系统已经设置的别名</li>
<li>su 切换用户<br>
<code>su - test</code><br>
切换到 wq 用户，并改变 wq 用户的环境变量，- 表示切换用户的环境变量</li>
<li>useradd 创建用户<br>
<code>useradd -m test</code></li>
<li><code>sudo passwd test</code><br>
设置用户密码</li>
<li>userdel 删除用户<br>
<code>sudo userdel -r test</code><br>
userdel 可删除etc/passwd 下的用户信息，但不会删除家目录<br>
-r 可以删除相关的目录信息</li>
<li>创建新用户并加入新创建的组<br>
<code>sudo useradd test_user</code> 创建新用户<br>
<code>sudo groupadd test_group</code> 创建新的用户组<br>
<code>sudo usermod -G test_group test_user</code> 将新用户加入新的组<br>
<code>sudo groupmod -n test_mod_group test_group</code>  将test_group 组名<br>
改为test_mod_group</li>
<li>查看文件权限<br>
<code>ls -la test_file</code></li>
<li>chmod 分配权限<br>
<code>sudo chmod u-r test_file</code><br>
u -文件所属者<br>
g -文件的所属组<br>
o -其他用户</li>
<li>查看发行版的详细信息<br>
<code>lsb_release -a</code></li>
<li>查看系统发行版本<br>
<code>less /etc/issue</code> q 退出<br>
<code>cat /etc/issue</code></li>
<li>查看软件版本信息<br>
<code>python --version</code></li>
<li>查看是否安装了某个软件包<br>
<code>sudo rpm -qa python</code></li>
<li>卸载已经安装的软件包<br>
<code>sudo rpm -e python --nodeps</code>  --nodeps 避免去检查相关的依赖环境导致不能卸载</li>
<li>安装软件<br>
<code>sudo yum install python36 -y</code></li>
<li>服务器重装后keys改了终端连接不上的方法<br>
<code>ssh-keygen -R</code> 在本机执行此命令即可</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正义不会缺席]]></title>
        <id>https://blog.qianqian.fun/post/zheng-yi-bu-hui-que-xi/</id>
        <link href="https://blog.qianqian.fun/post/zheng-yi-bu-hui-que-xi/">
        </link>
        <updated>2020-07-25T06:59:54.000Z</updated>
        <content type="html"><![CDATA[<p>最近关于来女士的案子在网上广为流传，虽然我们都希望她平安无事，但天不遂人愿。从出事到今天警方发布案子通告，真相虽然已经浮出水面，但是相信很多人都想不通，为什么枕边人竟就是那个凶手，当然我也没想明白，为什么好好的日子过成了这样。十年修得同船渡，百年修得共枕眠，原本应该相亲相爱携手渡百年的夫妻却以如今这段惨剧收场了，可怜他们那小女儿，这段经历在她心里也许永远都挥之不去。</p>
<p>究其原因竟然只是因为家庭琐事意见不合，在此我真的想说，广大同胞们，凡事都是可以心平气和的讨论的，遇事要及时沟通，不要积在心里。不要走极端，走极端就容易出问题，以上就是活生生的例子啊。有什么事情过不去非要以这种方式来解决呢。最后发生这种事的原因只是一个导火线，也许就是因为没有及时沟通，有些事日积月累，就导致了这样的恶果。那个作为凶手的丈夫，他但凡想着点家庭，孩子，及时沟通的话，也不会生出犯罪的想法，更不会酿成这样的惨案。</p>
<p>事已至此，我就希望来女士能安息，愿天堂没有恶魔。我希望凶手能诚心悔过，承担应有的责任，我更希望他们的小女儿能忘记这段过去，走出这个阴影，阳光快乐的生活。我还想说不要想着犯罪，无论你有多高明，我们的人民警察一定能抓住你，只不过事时间问题。要记住，天网恢恢，疏而不漏，正义也许会迟到，但是永远不会缺席！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用的命令-基础]]></title>
        <id>https://blog.qianqian.fun/post/linux-chang-yong-de-ming-ling-ji-chu/</id>
        <link href="https://blog.qianqian.fun/post/linux-chang-yong-de-ming-ling-ji-chu/">
        </link>
        <updated>2020-07-06T07:21:57.000Z</updated>
        <content type="html"><![CDATA[<p>这一篇文档记录了一些常用的命令，以备学习查询之用。并将这些命令进行分类整理，方便检索。</p>
<h2 id="export-环境变量">export-环境变量</h2>
<p>你知道什么是环境变量吗？如果你不知道，你应该运行这条命令：</p>
<pre><code>$ export
declare -x HISTCONTROL=&quot;ignoredups&quot;
declare -x HISTSIZE=&quot;1000&quot;
declare -x HOME=&quot;/home/dc2-user&quot;
declare -x HOSTNAME=&quot;10-255-0-106&quot;
declare -x LANG=&quot;en_US.UTF-8&quot;
declare -x LESSOPEN=&quot;||/usr/bin/lesspipe.sh %s&quot;
declare -x LOGNAME=&quot;dc2-user&quot;
......省略
</code></pre>
<p>是的，使用 <code>export</code> 可以将当前环境下的变量全部打印在屏幕上。所以说，环境变量的本质还是变量，只是这些变量会随着环境的变化而变化，比如登录用户发生了变化。<br>
有没有想过为什么会有环境变量的存在？<br>
举个例子，我写了一个程序，它需要调用 Java 程序去执行某些事情。但是很快我就遇到了问题，在我的机器上程序运行没有问题，换了朋友的机器就运行不了了。原来是因为朋友的机器上没有安装 Java。他安装了 Java，还是运行不了。为什么？原来是因为它安装的目录和我不一样。<br>
通过这个例子，你应该明白了吧？有些因素是和环境相关的，这些环境相关的因素是软件的开发者在软件的编写的时候无法预知的。这就需要环境本身来告诉我。还是以上面这个例子继续说:<br>
在安装 Java 程序的时候，需要设置 Java 程序的环境变量，比如说 JAVA_HOME 。这样其他的程序在调用 Java 的时候就知道 Java 安装在哪里了。<br>
除了 Java 安装在哪里，还需要知道当前登录的用户名是什么？当前用户的 Home 目录在哪里？临时目录在哪里？等等等等。 这就是环境变量存在意义：告诉环境中运行的软件，一些在他们的开发者开发的时候不能预测的因素 。<br>
除此之外， <code>export</code> 还可以设置环境变量，如下示例:</p>
<pre><code>$ export my_var=my_var_value
$ echo $my_var   ## my_var_value
</code></pre>
<h2 id="history-历史命令">history-历史命令</h2>
<p>使用 <code>history</code> 命令可以查看我们输入的命令的历史:</p>
<pre><code>$ history
    1  python --version
    2  pip --version
    3  sudo yum install python3
</code></pre>
<p>默认情况下，使用 <code>history</code> 命令输出的每一行都是由序号以及命令组成的，如果我想改变这个格式呢？可以通过设置环境变量的方式，改变 <code>history</code>  命令输入的格式，比如加入命令的执行时间:</p>
<pre><code>$ export HISTTIMEFORMAT='%F %T '
$ history
    1  2020-07-13 22:29:04 python --version
    2  2020-07-13 22:29:04 pip --version
    3  2020-07-13 22:29:04 sudo yum install python3
</code></pre>
<p>你有没有发现，这几条命令的执行时间都是一样的？是因为这些命令执行的时候，并没有通过设置 <code>HISTTIMEFORMAT</code> 环境变量的方式开启“记录命令执行时间戳”的功能，所以就以其最近记录的时间戳的命令为准。</p>
<pre><code>$ history | tail -n 3
  165  2020-07-13 22:41:19 cat
  166  2020-07-13 22:41:26 echo ok
  167  2020-07-13 22:41:33 history | tail -n 3
</code></pre>
<p>然后我们现在在执行几条命令， 发现时间都不一样了，对吧。另外，我们还可以设置记录历史命令的数量:</p>
<pre><code> $ echo $HISTSIZE     ## 默认为 1000
 $ export $HISTSIZE=2000
</code></pre>
<p>如果要清空历史记录，可以使用 <code>history -c</code>删除内存中记录的命令。但是，实际上命令是记录在 <code>.bash_history</code> 这个文件中的，所以真正要删除命令，避免下次登录的时候重新加载该文件中的内容，可以使用 <code>history -w</code>命令。<br>
下表记录了，<code>history</code> 命令相关的环境变量:</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HISTCONTROL=erasedups</td>
<td>清除整个命令中的重复条目</td>
</tr>
<tr>
<td>HISTCONTROL=ignoredups</td>
<td>忽略记录命令历史中连续重复的命令</td>
</tr>
<tr>
<td>HISTCONTROL=ignorespace</td>
<td>忽略记录空格开始的命令</td>
</tr>
<tr>
<td>HISTCONTROL=ignoreboth</td>
<td>等价于 ignoredups 和 ignorespace</td>
</tr>
</tbody>
</table>
<p>如果要执行上一条命令，可以使用 <code>!!</code> , 如果要执行历史命令中的某一条命令，可以使用 <code>!&lt;序号&gt;</code> :</p>
<pre><code>$ !!         ## 执行上一条命令
$ history
    1  clear
    2  history
    3  cat ~/.bash_history
$ !3
</code></pre>
<h2 id="date-系统时间">date-系统时间</h2>
<p>在 Windows 上，我们可以通过查看状态栏，得知现在是什么时候了。而在 Linux 中，我们通过什么命令来知晓时间呢？——  <code>date</code> 。</p>
<pre><code>$ date
Tue Jul 14 13:25:30 CST 2020
如果是 CentOS/7 发行版，我们可以使用下面这个命令:
$ timedatectl
      Local time: Tue 2020-07-14 13:30:18 CST     ## 本地时间
  Universal time: Tue 2020-07-14 05:30:18 UTC     ## 世界协调时间
        RTC time: Tue 2020-07-14 05:30:18         ## RTC 芯片的时间
       Time zone: Asia/Shanghai (CST, +0800)      ## 时区
  .....省略
</code></pre>
<p>如果时区不对，对造成各类服务时间错误，与第三方对接授权错误，所以应该使用如下命令调整时区：</p>
<pre><code>$ timedatectl set-timezone &quot;Asia/Shanghai&quot;   # 设置时区
$ timedatectl list-timezones    # 查看所有时区
</code></pre>
<p>注意： 建议将时区全部设置为上海，因为一般大型的互联网企业都在上海设置数据中心。在与这些服务商通信的时候，可以尽可能避免因为细小的时间差距从而导致的错误。<br>
另外，受限于硬件的精准度，所以我们需要启动 NTP 时间同步服务，与授时服务器定时同步时间，以保证时间的准确:</p>
<pre><code>$ timedatectl set-ntp true
</code></pre>
<h2 id="time-你的程序跑的有多快">time-你的程序跑的有多快</h2>
<p>我们可以使用 time 来查看程序运行花了多少的时间:</p>
<pre><code>$ time php -i &gt;&gt; /dev/null
php -i &gt;&gt; /dev/null  0.06s user 0.01s system 95% cpu 0.074 total
</code></pre>
<p>上面这条命令的含义是我们使用 <code>time</code> 来测试 <code>php -i &gt;&gt; /dev/null</code> 这条命令花了多长的时间，其输出的解释如下:</p>
<pre><code>命令 用户态时间 user 内核态时间 system CPU占用 cpu 总共花费时间 total
</code></pre>
<p>所以，这条命令 CPU 的运算时间是 用户态时间+ 内核态时间，而总共花费的时间减去 CPU 的运算时间是中间等待 CPU 分片的时间。</p>
<h2 id="htop-查看cpu-内存-进程">htop-查看CPU、内存、进程</h2>
<p>在大多数的 Linux 发行版中，都使用 top 来实时查看系统资源，比如 CPU、内存以及进程的相关信息。现在，我们可以使用 htop 来代替 top 这个程序了。使用 htop 更加的简洁易用、直观明了。<br>
可以使用包管理工具来安装 htop, 比如在 CentOS8 下，可以使用 <code>sudo dnf install htop -y</code> 。<br>
然后输入 <code>htop</code> 即可查看系统资源占用情况, 如下图所示:<br>
<img src="https://blog.qianqian.fun/post-images/1599549979877.png" alt="" loading="lazy"><br>
可以按下 <code>F1</code> 来查看帮助，可以使用 <code>q</code> 或者 <code>F10</code> 退出程序。可以使用 <code>F4</code> 过滤进程， 使用 <code>F5</code> 排序，按下 <code>t</code> 可以查看进程的父子层级。按下 <code>u</code> 可以显示所有进程的用户列表，并根据用户列表来过滤进程信息。<br>
更多的用户可以参考帮助信息:<br>
<img src="https://blog.qianqian.fun/post-images/1599550091813.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[压力测试工具ab]]></title>
        <id>https://blog.qianqian.fun/post/ya-li-ce-shi-ab/</id>
        <link href="https://blog.qianqian.fun/post/ya-li-ce-shi-ab/">
        </link>
        <updated>2020-06-27T05:45:57.000Z</updated>
        <content type="html"><![CDATA[<p>首先，我找到一个人的 blog，网址是https://blog.codingnow.com/，我想对这个页面进行压力测试，怎么做？我们使用ab工具来进行测试，centos8 的发行版就自带了这个软件。</p>
<pre><code>ab -n500 https://blog.codingnow.com/
</code></pre>
<p>返回比较慢，我们换一个网址：</p>
<pre><code>ab -n3000 http://165.84.180.25/index.html
</code></pre>
<p><code>-n</code> 是指定我们的请求数，一共请求了 3000 次<br>
<img src="https://blog.qianqian.fun/post-images/1598507506230.png" alt="" loading="lazy"><br>
你看，结果中显示我们的服务器每秒大概可以处理 4961.70 个这样的请求，但是我们这个只是静态页面。<br>
然后我们来测试一下我们之前写的 hello 接口：<br>
<img src="https://blog.qianqian.fun/post-images/1598507943315.png" alt="" loading="lazy"></p>
<pre><code>ab -n1000 http://165.84.180.25/WeChat.Message/hello
</code></pre>
<p><img src="https://blog.qianqian.fun/post-images/1598508112520.png" alt="" loading="lazy"><br>
明显慢了很多<br>
<img src="https://blog.qianqian.fun/post-images/1598508013114.png" alt="" loading="lazy"><br>
每秒只能处理 15.96 个请求<br>
<img src="https://blog.qianqian.fun/post-images/1598508370974.png" alt="" loading="lazy"><br>
应该是这样的结果<br>
<img src="https://blog.qianqian.fun/post-images/1599551466506.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL踩坑记（一）]]></title>
        <id>https://blog.qianqian.fun/post/mysql-cai-keng-ji/</id>
        <link href="https://blog.qianqian.fun/post/mysql-cai-keng-ji/">
        </link>
        <updated>2020-05-05T07:53:02.000Z</updated>
        <content type="html"><![CDATA[<p>错误：ERROR 1130: Host '140.143.11.127' is not allowed to connect to thisMySQL serve</p>
<p>错误1130：主机140.143.11.127”不允许连接到thismysql服务</p>
<p>原因：被连接的数据不允许使用 140.143.11.127访问，只允许是用 localhost</p>
<p>启用终端<br>
输入 ： mysql -u -root -p</p>
<p>mysql&gt;use mysql;</p>
<p>mysql&gt;select 'host' from user where user='root';</p>
<p>mysql&gt;update user set host = '%' where user ='root';</p>
<p>mysql&gt;flush privileges;</p>
<p>mysql&gt;select 'host'   from user where user='root';</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是 Linux]]></title>
        <id>https://blog.qianqian.fun/post/shi-me-shi-linux/</id>
        <link href="https://blog.qianqian.fun/post/shi-me-shi-linux/">
        </link>
        <updated>2020-04-08T08:32:34.000Z</updated>
        <content type="html"><![CDATA[<p>简单的说， Linux 和 Windows 、macOS 一样，都是操作系统，而操作系统本质上来讲也是一种软件(超大型的软件，代码量都在千万级以上)。</p>
<p>Linux 对于我们最大的意义在于，绝大多数的服务器上都使用 Linux 作为操作系统。我们的产品的开发、测试也都在 Linux 系统上进行操作。</p>
<h2 id="搭建-linux-环境">搭建 Linux 环境</h2>
<p>搭建 Linux 环境大致有两种做法，一种是在本地(虚拟机)模拟一台服务器，然后安装 Linux 系统。另外一种就是选择云服务器厂商购买一台在线的服务器。</p>
<p>我更倾向于第二种方式，更加的快捷方便，但是需要一定的学习成本。第一种方式，对本地电脑的配置有一定要求，但是成本相对较低。</p>
<p>如果选择云服务器产品的话，可以选择阿里云、腾讯云、百度云、京东云、滴滴云、青云等等。滴滴云的成本最低，阿里云的应用较为广泛。对于初期学习而言，其实也都差不多，生产环境一般会选择阿里云或者腾讯云，如果是服务国外，可能会选择阿里云、Google Cloud Platform 以及亚马逊云。</p>
<h2 id="什么是发行版">什么是发行版</h2>
<p>在购买服务器的时候，会要求选择操作系统，当然我们会选择 Linux，另外还会要求选择 Linux 的发行版。那么什么是发行版呢？</p>
<p>简单的来说，我们平时所说的 Linux 指的是 Linux 内核(可以理解成 Linux 的核心）。不同的厂商、组织、开发者会针对某一版本的 Linux 内核做一些优化、加装一些软件形成自己的发行版本。</p>
<p>常见的发行版有 CentOS、RedHat、Ubuntu、Debian 等等。生产环境一般选用 CentOS, 而学习的话可以选择 CentOS 或者 Ubuntu。不严谨的定义，如下:</p>
<pre><code>Linux 发行版 = Linux 内核 + 其他的软件
</code></pre>
<p>接下来的系列文章，都会采用 CentOS 7.6 版本或者更高。</p>
<h2 id="初识命令行">初识命令行</h2>
<p>相对于 Windows，我们所有的操作都是在图形化的界面中完成的，Linux 的所有操作都可以在命令行中完成。这样的操作更加的原始，但却更加的快速有效。</p>
<p>另外，Linux 的服务器一般都在异地的大型机房中，我们都需要通过网络连接去操作它。使用命令行传输指令相对于传出图形界面，会占用更小的带宽，传输更快。</p>
<p>Linux 的命令行界面一般如下图所示:</p>
<figure data-type="image" tabindex="1"><img src="https://blog.qianqian.fun/post-images/1599554112148.png" alt="" loading="lazy"></figure>
<p>初学者对于这样的界面是困惑的，黑漆漆的背景，几个不知道含义的文本，不知道怎么做。但是我相信，你很快就会喜欢上这样的界面，因为它非常的高效，极客。</p>
<p>这就是命令行，你可以用各种各样的命令去做任何你想做的事情，前提是你需要理解命令的运作机制，这是学习 Linux 的第一道门槛，跨过去！</p>
<p>我们使用操作系统，通常是为了使用一些基于操作系统的软件，不管是聊天软件还是游戏软件或者是浏览器。因为在 Linux 中，我们通常都是使用命令行的，所以没有平时使用 Windows 中看到的哪些界面。而所谓的命令，其实就是一个个的软件，我们通过下面这种方式去运行，而不是通过鼠标去界面上点击：</p>
<figure data-type="image" tabindex="2"><img src="https://blog.qianqian.fun/post-images/1599554549565.png" alt="" loading="lazy"></figure>
<p>你看，你平时使用微信或者QQ，是不是要鼠标双击 QQ或者微信的图标啊，那么在命令行中，我们并不需要用鼠标，只需要输入 QQ 就可以了。另外，当你打开QQ 的界面的时候，你需要告诉QQ你的用户名和密码，而在 命令行中使用命令行参数来告诉运行的软件一些信息, 比如 <code>--username</code>  和 <code>--password</code> 。</p>
<p>所以，你其实不用恐惧命令行，学习 Linux 其实就是学习这些软件怎么使用，就和你学习微信、QQ 如何使用一样，只是稍微比微信、QQ 这样的软件要复杂一点点。</p>
<p>所以，究其本质来说，命令行和图形化界面没有什么区别，只是一个是通过文本来运行软件，一个是通过界面来简化软件的使用罢了 。理解这一点很重要！</p>
<h2 id="常用的命令">常用的命令</h2>
<p>下面介绍一些常用的软件(命令), 不要去死记硬背，只要常常去用就好了。首先，我们创建一个文件夹, 这个文件夹名字叫做 <code>test</code> ：</p>
<pre><code>## 创建一个名为 test 的文件夹
mkdir test
## 把当前的目录切换到名为 test 的文件夹
cd test
## 创建一个文件
touch test.txt
## 查看文本内容
cat test.txt
## 查看当前所在的目录
pwd
## 计算 1 + 1
expr 1 + 1
</code></pre>
<p>你会发现，如果熟练掌握了这些命令，那种用鼠标去点击各种按钮的操作会显得非常没有效率。接下来，我们来安装一个软件:</p>
<pre><code>sudo yum install wget -y
</code></pre>
<p>相对上面的命令，这个看上去要复杂很多,解释一下:</p>
<p>如果你登录的账户是 root 用户，并不需要使用 sudo 就可以拥有安装软件的权限。因为 root 是 Linux 中权力做大的用户。否则，你可能需要使用 sudo 去提升你的权限，sudo 的意思就是 super to do ，使用超级管理员的权限去做某件事。</p>
<p>yum 是 CentOS 发行版中使用的软件管理工具，你可以使用它来安装一些软件，就像是 Windows 上的 360 软件管家。</p>
<p>install 是 yum 的子命令，表示安装。</p>
<p>wget 是要安装的名字。而 -y 是说直接安装，不需要我确认了。</p>
<p>我举一个 qq 发送消息的例子:</p>
<pre><code>qq send hello -to bob
</code></pre>
<p>这条命令翻译过来就是: 使用 qq 这个软件发送给 bob 这个人一条消息，消息的内容为 &quot;hi&quot; 。</p>
<p>这个 wget 是干什么的呢？就像是 Windows 上的迅雷，用来下载文件的:<br>
wget http://downloads.end.wiki/hello.txt</p>
<p>用法非常简单，后面跟上文件的地址就可以了。</p>
<h2 id="使用网络学习命令">使用网络学习命令</h2>
<p>其实命令行就这么简单，不需要死记硬背，用到的时候去查一下，多用用就好了。下面推荐一个地址，用来学习、搜索各种命令:  [ Linux 命令大全(手册) ] [ https://www.linuxcool.com/ ]。这个网站对命令提供了搜索功能，对一些常见的命令还进行了分类:</p>
<figure data-type="image" tabindex="3"><img src="https://blog.qianqian.fun/post-images/1599555382438.png" alt="" loading="lazy"></figure>
<h2 id="使用-man-手册">使用 man 手册</h2>
<p>如果有一个人问我，这条命令怎么用，我会告诉他去问那个男人(man)。在 Unix/Linux 这个男人大名鼎鼎，比谁都更了解 Unix/Linux。其实 man 并不是指男人的意思，而是英文单词 manuals 的缩写，意为手册。</p>
<pre><code>man man
</code></pre>
<p>man 是 Unix/Linux 系统手册，我们可以使用 man 来查看 man 命令的帮助:</p>
<pre><code>man - an interface to the on-line reference manuals
</code></pre>
<p>它是一个在线的参考手册的接口，首先是参考手册，然后你自己的程序也可以实现它的接口，提供程序的帮助信息。</p>
<p>这个参考手册分为若干的章节(section)，如下:</p>
<ol>
<li>章节 1 : 一般的命令</li>
<li>章节 2 : 系统调用</li>
<li>章节 3: C 库函数</li>
<li>章节 4: 特殊文件</li>
</ol>
<p>比如我们查询 sh 这条 Shell 的命令，可以使用如下方式:</p>
<pre><code>man 1 sh
</code></pre>
<p>然后关于 <code>sh</code>  这条命令的显示信息如下:</p>
<figure data-type="image" tabindex="4"><img src="https://blog.qianqian.fun/post-images/1599555628348.png" alt="" loading="lazy"></figure>
<p>按下 <code>q</code> 可以退出，按下 <code>CTRL+F</code> 可以翻页。</p>
<h2 id="更换镜像源">更换镜像源</h2>
<p>由于某种不能抗拒的原因，国内访问国外的网站、服务都特别的慢。当我们使用 Yum 去安装各种软件的时候，由于服务器都在国外，经常会安装失败或者速度慢到不能忍受。</p>
<p>这时候，我们可以尝试更换成国内的镜像源。比如说阿里云、腾讯云等服务商会定时去同步国外 Yum 的官方服务器资源到国内自己的服务器上。当我们使用 Yum 去更新或安装的时候，就会比较快。</p>
<pre><code>## 备份原有配置文件
sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
## 下载源配置文件
sudo wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.tencent.com/repo/centos7_base.repo
## 清理缓存并重建立
sudo yum clean all
sudo yum makecache
</code></pre>
<p>上面是 CentOS7 的实例，其他的发行版或不同的版本请访问腾讯官方：腾讯 CentOS 源帮助文档。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub 使用语法]]></title>
        <id>https://blog.qianqian.fun/post/ce-shi-wen-zhang/</id>
        <link href="https://blog.qianqian.fun/post/ce-shi-wen-zhang/">
        </link>
        <updated>2020-01-30T16:51:07.000Z</updated>
        <content type="html"><![CDATA[<p>一个 # 号表示一号标题，比如</p>
<h1 id="一号标题">一号标题</h1>
<p>‘Ctrl + P’可以预览效果</p>
<p>很自然的，##二号标题，###三号标题，####四号标题......一直到六号标题</p>
<h2 id="二号标题">二号标题</h2>
<h3 id="三号标题">三号标题</h3>
<h4 id="四号标题">四号标题</h4>
<h5 id="五号标题">五号标题</h5>
<h6 id="六号标题">六号标题</h6>
<p>在文字的前后加上 两个 ‘ ** ’表示加粗，一个 ‘  * ’表示斜体。比如：<strong>加粗</strong>，<em>斜体</em></p>
<p>如果你要插入代码，分为两种，一种是行内代码，代码前后使用*‘*符号包裹，。</p>
<p><code>print 'Hello World'</code></p>
<p>如果你要插入多行代码，可以使用 如下：</p>
<pre><code>def index():
    print 'Hello World'
</code></pre>
<p>如果是列表：</p>
<ul>
<li>列表项一</li>
<li>列表项二</li>
<li>列表项N</li>
</ul>
<p>上面的是无序列表，有序列表如下：</p>
<ol>
<li>列表项一</li>
<li>列表项二</li>
<li>列表项三</li>
<li>列表项N</li>
</ol>
<p>掌握以上的这些基本就可以完成一篇比较漂亮的文章了。</p>
]]></content>
    </entry>
</feed>