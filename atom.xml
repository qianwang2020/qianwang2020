<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.qianqian.fun</id>
    <title>汪小白的博客</title>
    <updated>2020-09-08T10:35:46.993Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.qianqian.fun"/>
    <link rel="self" href="https://blog.qianqian.fun/atom.xml"/>
    <subtitle>用勤劳的双手换取想要的生活</subtitle>
    <logo>https://blog.qianqian.fun/images/avatar.png</logo>
    <icon>https://blog.qianqian.fun/favicon.ico</icon>
    <rights>All rights reserved 2020, 汪小白的博客</rights>
    <entry>
        <title type="html"><![CDATA[Python基础语法]]></title>
        <id>https://blog.qianqian.fun/post/ji-chu-yu-fa/</id>
        <link href="https://blog.qianqian.fun/post/ji-chu-yu-fa/">
        </link>
        <updated>2020-09-05T09:24:57.000Z</updated>
        <content type="html"><![CDATA[<p>这一系列的文档使用 Python3, 采用 Linux 环境编程。</p>
<h2 id="hello-world">Hello World</h2>
<p>我们先从 Hello World 开始:</p>
<pre><code>print(&quot;Hello World!&quot;)
</code></pre>
<h2 id="定义变量">定义变量</h2>
<p>上面使用的 <code>&quot;Hello World&quot;</code> 是一个字符串，我们可以将这个字符串赋值给一个变量:</p>
<pre><code>message = &quot;Hello World&quot;
print(message)
</code></pre>
<h2 id="变量的类型">变量的类型</h2>
<p>我们的变量是有类型的？ 为什么需要有类型呢？因为这些变量的值都需要存储在内存中，不同类型的值在内存中的占用容量也不一样。所以我们定义了类型，以便在内存中提前为这些变量的值开辟空间 。</p>
<p>Python 中支持的类型如下图所示:</p>
<figure data-type="image" tabindex="1"><img src="https://blog.qianqian.fun/post-images/1599557260246.png" alt="" loading="lazy"></figure>
<h2 id="字符串和数值">字符串和数值</h2>
<p>最常见的类型莫过于字符串和数值了，在我们的生活中也无时不刻在用。比如我们去买菜，买了什么？白菜，白菜是一个名字，是一个字符串。这个白菜多少一斤呢？1块钱一斤，那么这个1块钱就是数值。</p>
<p>我们之前定义的 message 的变量就是一个字符串类型。不同的类型，会有不同的方法？什么是方法啊？就是预定义的操作。比如我们可以将字符串全部转成小写输出:</p>
<pre><code>message = &quot;Hello World&quot;
print(message.lower())  ## Hi, Bob
</code></pre>
<p>此外，我们还可以将多个字符串通过 <code>+</code> 拼接起来，就拿打招呼为例:</p>
<pre><code>name = &quot;Bob&quot;
print(&quot;Hi,&quot; + &quot; &quot; + name)
</code></pre>
<p>接着，如果我去买菜，花了5.8，然后递给买菜的大妈一张 10 元人民币，按照道理她应该找我 3.2 元。但是呢？我想要这两毛钱也没什么用，我就说凑个整吧:</p>
<pre><code>price = 5.8
print(round(price))
此外，我们还可以对数值进行运算:
print(10 * 10)  ## 100
print(20 - 10)  ## 10
print(30 / 2)   ## 15
print(15 + 16)
</code></pre>
<h2 id="列表和元组">列表和元组</h2>
<p>在实际的生活中，我们经常会对事物按照不同的维度进行归类分组。而程序最大的目的就是为了模拟现实，解决现实中的一些问题。对于一组的数据，在程序中，我们可以通过 <code>列表</code> 这个概念来表示:</p>
<pre><code>languages = [&quot;PHP&quot;, &quot;Python&quot;, &quot;Java&quot;, &quot;C&quot;]
print(languages)   ## ['PHP', 'Python', 'Java', 'C']
</code></pre>
<p>我们可以访问这个列表中的每一个元素，通过下标, 即为列表中的每一个元素按顺序进行标号，从 0 开始:</p>
<pre><code>languages = [&quot;PHP&quot;, &quot;Python&quot;, &quot;Java&quot;, &quot;C++&quot;]
print(languages[0], languages[3])            ## PHP C++
</code></pre>
<p>既然可以访问，就可以修改:</p>
<pre><code>languages = [&quot;PHP&quot;, &quot;Python&quot;, &quot;Java&quot;, &quot;C++&quot;]
languages[2] = &quot;C&quot;
print(languages[2])  ## C
</code></pre>
<p>可以追加，可以删除:</p>
<pre><code>languages = [&quot;PHP&quot;, &quot;Python&quot;, &quot;Java&quot;, &quot;C++&quot;]
# 在列表的末尾添加
languages.append(&quot;Swift&quot;)
# 在指定的位置添加
languages.insert(1, &quot;Ruby&quot;)
languages.pop(1)
print(languages)        ## ['PHP', 'Python', 'Java', 'C++', 'Swift']
可以对列表进行排序:
languages = [&quot;PHP&quot;, &quot;Python&quot;, &quot;Java&quot;, &quot;C++&quot;]
languages.sort()           ## ['C++', 'Java', 'PHP', 'Python']
print(languages)
languages.reverse()        ## ['Python', 'PHP', 'Java', 'C++']
print(languages)
</code></pre>
<p>元组和列表十分相似，最大的区别在于元组中元素的地址是不可变的 。</p>
<pre><code>## 定义并计算元组长度
pers = (&quot;Bob&quot;, &quot;Foo&quot;, &quot;June&quot;)
print(len(pers))  ## 3
</code></pre>
<p>如果你尝试对元组中的元素的值进行重写的话，会产生一个错误:</p>
<pre><code>pers = (&quot;Bob&quot;, &quot;Foo&quot;, &quot;June&quot;)
pers[0] = &quot;Wang&quot;
</code></pre>
<p>运行上面的程序，会输出如下错误:</p>
<pre><code>C:\Users\admin\PycharmProjects\test\venv\Scripts\python.exe C:/Users/admin/PycharmProjects/test/test.py
Traceback (most recent call last):
  File &quot;C:/Users/admin/PycharmProjects/test/test.py&quot;, line 2, in &lt;module&gt;
    pers[0] = &quot;Wang&quot;
TypeError: 'tuple' object does not support item assignment
Process finished with exit code 1
</code></pre>
<h2 id="字典">字典</h2>
<p>在现实的生活中，总有一些人的名字会让我们感到尴尬，因为当中的某个字我不认识。这时候，我就需要去查字典, 比如这个名字：林茜。通过查字典我知道，这个茜字有两个含义两个读音:<br>
• 茜(qian: 第四声)：茜草，多年生攀缘草本植物。茎方形，有倒刺。根黄红色，可提取染料，也可供药用。<br>
• 茜(xi: 第一声): 音译用字。多用于外国女子名。<br>
通过上面这个例子，大概能感觉到，字典是一种映射，为了方便查询。在 Python 中，也提供了字典类型，提供了从 key 到 value 的映射。</p>
<pre><code>words = {&quot;qian&quot;: &quot;茜草，多年生攀缘草本植物。茎方形，有倒刺。根黄红色，可提取染料，也可供药用&quot;, &quot;xi&quot;: &quot;音译用字。多用于外国女子名&quot;}
print(words[&quot;qian&quot;])  # 茜草，多年生攀缘草本植物。茎方形，有倒刺。根黄红色，可提取染料，也可供药用
print(words[&quot;xi&quot;])  # 音译用字。多用于外国女子名
</code></pre>
<p>和列表一样，我们可以对字典中的键值对进行添加、修改以及删除操作:</p>
<pre><code>user = {&quot;name&quot;: &quot;admin&quot;, &quot;age&quot;: 14, &quot;email&quot;: &quot;admin@end.wiki&quot;}
# 修改年龄
user['age'] += 1
# 添加工作
user['job'] = &quot;soft developer&quot;
# 删除邮箱
del user['email']
print(user)   # {'name': 'admin', 'age': 15, 'job': 'soft developer'}
</code></pre>
<h2 id="分支以及循环">分支以及循环</h2>
<p>编程语言中核心的概念并不多，其中最基本的是变量、分支、循环。我们的代码按照执行顺序可以分为三种结构，分别是顺序、分支以及循环。</p>
<p>所谓顺序，就是上一行代码执行完成之后执行下一行代码。所谓分支，就是对条件进行判断，然后执行对应的代码块。而循环，则是对某一段代码进行多次执行，根据其是否满足条件决定执行的次数。</p>
<h3 id="分支">分支</h3>
<p>我们的生活中处处都存在着抉择，每一次抉择，都会或多或少改变我们人生的走向。比如晚上我是吃饭还是吃面:</p>
<pre><code>food = &quot;noodles&quot;
if food == &quot;noodles&quot;:
    print(&quot;走去兰州拉面&quot;)    ## 还是吃面吧
else:
    print(&quot;走去地沟油菜馆&quot;)
</code></pre>
<p>但是生活的难并不仅仅是在于没有选择的余地，有时候也会出现有太多的选择:</p>
<pre><code>needs = &quot;我想要钱，我想要房子，我想要名望，我想要...&quot;
if needs == &quot;money&quot;:
    print(&quot;奋斗或偷盗&quot;)
elif needs == &quot;house&quot;:
    print(&quot;租或者买&quot;)
elif needs == &quot;popular&quot;:
    print(&quot;选秀或者扑街&quot;)
else:
    print(&quot;做梦&quot;)
</code></pre>
<h3 id="循环">循环</h3>
<p>使用 while 语句进行循环，并通过对数值变量的递增或递减控制循环的次数:</p>
<pre><code>i = 1
while i &lt;= 5:
    print(i)
    i += 1
</code></pre>
<p>在循环中，也可以通过 <code>continue</code> 跳过某次循环，或者通过 <code>break</code> 结束循环。<br>
对列表或元组进行循环:</p>
<pre><code>languages = [&quot;PHP&quot;, &quot;Python&quot;, &quot;Java&quot;, &quot;Swift&quot;]
for language in languages:
    print(language)
</code></pre>
<p>对字典进行循环:</p>
<pre><code>user = {&quot;name&quot;: &quot;admin&quot;, &quot;email&quot;: &quot;admin@end.wiki&quot;, &quot;country&quot;: &quot;China&quot;, &quot;Job&quot;: &quot;soft developer&quot;}
for k in user:
    print(k + &quot;\t:&quot; + user[k])
</code></pre>
<p>输出内容如下:</p>
<pre><code>name    :admin
email   :admin@end.wiki
country :China
Job :soft developer
</code></pre>
<h2 id="函数">函数</h2>
<p>函数是对一段代码的分装，一个函数是一个动作、操作。比如一个函数是一声问候:</p>
<pre><code>def greet():
    print(&quot;Hello&quot;)
greet()    # Hello
</code></pre>
<p>也可以指定一个人问候:</p>
<pre><code>def greet(name):
    print(&quot;Hello, &quot; + name)
greet(&quot;Bob&quot;)   # Hello, Bob
</code></pre>
<p>为函数的传参指定一个默认值:</p>
<pre><code>def greet(name = &quot;Bob&quot;):
    print(&quot;Hello, &quot; + name)
greet()    # Hello, Bob
</code></pre>
<p>调用函数的时候，也可以指定传参的名称，可以增加可读性:</p>
<pre><code>def greet(name = &quot;Bob&quot;):
   print(&quot;Hello, &quot; + name)
greet(name = &quot;Foo&quot;)   # Foo
</code></pre>
<p>函数可以有返回值:</p>
<pre><code>def sum(num1, num2):
    return num1 + num2
print(sum(1, 2))   # 3
</code></pre>
<p>也可以传递任意数量的参数:</p>
<pre><code>def sum(*numbers):
    total = 0
    for number in numbers:
        total += number
    return total
print(sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))  # 55
</code></pre>
<h2 id="模块module">模块(Module)</h2>
<p>上面我们这些内容都是很基础的，三两行代码，所以放在一个文件里也是没什么问题。如果我们真得去写一个项目，代码量可能就不会是三两行，而是三四千行、万行、数十万行。这么多的代码，可不能放在一个文件里哦，不方便管理和维护。</p>
<p>那么，我们就会将代码分割成不同的部分，放在不同的文件中。这时候，我们就可以使用模块了，一个模块其实就是一个以 <code>.py</code> 结尾的 Python 代码文件。这个文件中，声明了一些可能会被其他模块用到的变量、函数以及类。比如我们申明如下这个模块（文件命令为 database.py，当中有一个 Database 的类, 用来操作数据库:</p>
<pre><code>class Database:
    def query(self):
        print('Query Database...')
class Mysql:
    def query(self):
        print('MySQL query Database...')
</code></pre>
<p>模块有了，那么如何在其他的代码文件中引入这个模块中的这个 Database 类呢?</p>
<pre><code>import database
db = database.Database()
database.query()  # Query Database...
</code></pre>
<p>如果我并不像引入这个 database 文件，只是向引入部分内容呢？</p>
<pre><code>from database import Mysql
mysql = Mysql()
mysql.query()    # MySQL query Database...
</code></pre>
<p>虽然，我们也可以使用 <code>from databases import *</code> 来导入 database 模块中所有的内容(变量、函数以及类)。但是不可以这么做，因为这样做的话，你在阅读代码的时候，不知道这个变量、函数或者类来自哪里？因为你引入的时候使用了 <code>*</code> 号这个通配符，并没有说明从这个文件中引入了什么。</p>
<h2 id="包package">包(Package)</h2>
<p>如果说模块是对变量、函数以及类的封装，那么包就是对模块的封装。简单的说，包当中含有模块，而模块中包含类、函数以及变量。</p>
<p>之所以会有模块、包这样的概念，就是因为随着代码量的增大，需要对代码进行拆分管理。这非常好理解，就像人多了之后，需要对人进行拆分管理，比如亚洲、中国、浙江、杭州、西湖区、XX街道、XX小区、3幢、一单元、201室......为什么需要分的那么细？因为人太多了，不分不方便管理。 分而治之是计算机中非常常见以及重要的思想 。</p>
<p>那么怎么创建一个包呢？很简单，再一个目录中创建一个空的文件，命名为 <code>__init__.py</code> 即可。这么文件所在的目录就是一个包。</p>
<pre><code>mkdir pack &amp;&amp; touch pack/__init__.py
</code></pre>
<p>然后我们再这个包当中加入一个模块,命名为 <code>pack/data.py</code> ，模块中包含一个方法:</p>
<pre><code>def greet():
    print('Hello')
</code></pre>
<p>然后，我们一个文件，名为 <code>app.py</code> , 文件内容如下:</p>
<pre><code>import pack.data
pack.data.greet()
</code></pre>
<p>也可以写成如下形式:</p>
<pre><code>from pack.data import greet
greet()
</code></pre>
<p>包当中还可以包含子包，和目录层级一致，比如包名是 <code>package.sub.module</code> ,那么路径名也应该是 <code>package/sub/module.py</code>。</p>
<p>经过这样一个例子，你明白为什么 Python 可以将我们拆分开的代码重新组合再一起执行了吗？<strong>当我们执行 <code>python app.py</code> 的时候，python 的解释器会去逐行解释代码，当发现代码以 <code>import</code> 或者 <code>from</code> 开头的时候，会根据包名和模块名找寻对应的目录下的代码文件，然后将对应的文件内容插入 <code>app.py</code> 中逐行执行</strong>。</p>
<figure data-type="image" tabindex="2"><img src="https://blog.qianqian.fun/post-images/1599558023140.png" alt="" loading="lazy"></figure>
<h2 id="异常处理exception">异常处理(Exception)</h2>
<p>我们总是希望生活是美好的，总是希望明天充满了希望，但现实生活也总是希望和失望相互交织。在程序中也是如此，我们希望程序可以从头到尾没有任何问题，但我们这么天真的想法本身就是问题。</p>
<p>于是，在生活中，我们开始学着为自己找好退路。而在编程中，我们也会尽可能去假设会出现问题，提前<strong>捕获异常(Catch exception)</strong>。</p>
<p>最简单的一个例子，除数不能为 0，但却写出了这样的代码:</p>
<pre><code>$ python -c &quot;print(1/0)&quot;
Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
ZeroDivisionError: division by zero
</code></pre>
<p>然后程序给你一个无情的耳光，没办法再执行下去了。有的同学会说，我知道除数不能为 0，所以我不会写出这样的代码的。但是，程序是由万千的变量和分支组成的，很多数据也是来源于我们的用户或者第三方是我们不能掌控的。 所以，<strong>异常是不可能避免的，但是可以提前预防的</strong>。</p>
<p>再比如说，当使用 Python3 去运行 Python2 的某些语法的时候:</p>
<pre><code>$ python2 -c &quot;print 'Hello World'&quot;
Hello World
$ python3 -c &quot;print 'Hello World'&quot;
  File &quot;&lt;string&gt;&quot;, line 1
    print 'Hello World'
                      ^
SyntaxError: Missing parentheses in call to 'print'. Did you mean print('Hello World')?
</code></pre>
<p>Python3 是一个不能向下兼容的版本，所以比如 <code>print 'Hello World'</code> 这样的语句在 Python3 中是无法执行的。抛出了一个异常 —— SyntaxError 。</p>
<p>当我们预感代码可能会抛出异常的时候，可以捕获异常进行处理，记录日志:</p>
<pre><code>try:
    fdajljfdjalfjdlkajfdasjfldsa
except:
    print('syntax error')
print('continue')
</code></pre>
<p>另外，我们还可以对特定的异常进行捕获:</p>
<pre><code>try:
    1 / 0
except (ZeroDivisionError):
    print('Zero Division Error')
except:
    print('syntax error')
print('continue')
</code></pre>
<p>通常，发生异常的时候，我们会希望能够提供更多的异常相关的信息, 我们可以使用 <code>as</code> 关键字来获取 <strong>异常对象（没错，异常也是对象)</strong> :</p>
<pre><code>try:
    1 / 0
except ZeroDivisionError as e:
    print('Zero Division Error:' + e.__class__.__name__) # Zero Division Error:ZeroDivisionError
except:
    print('syntax error')
print('continue')
</code></pre>
<p>另外，Python 还提供了两个关键字, 分别是 <code>else</code> 和 <code>finally</code>：</p>
<pre><code>try:
    1 / 0
except ZeroDivisionError as e:
    print('Zero Division Error:' + e.__class__.__name__)
except:
    print('syntax error')
else:
    print('normal')
finally:
    print('exception')
</code></pre>
<p><code>else</code> 只有在没有发生异常的时候会执行，而 <code>finally</code> 是不管有没有发生异常，都会执行。</p>
<p>上面看到的示例都是 Python 解释器抛出的异常，我们自己也可以抛出异常, 使用 <code>raise</code> 关键字:</p>
<pre><code>python3 -c &quot;raise TypeError('Type Error')&quot;
</code></pre>
<p>上面的 TypeError 也是 Python 自带的，我们可以自定义异常类，继承 BaseException 类。</p>
<pre><code>class UserNotFound(Exception):
    def __init__(self, user_id):
        super().__init__(&quot;User not found ${}&quot;.format(user_id))
        self.user_id = user_id
raise UserNotFound(10010)
</code></pre>
<p>执行这段代码，抛出自定义的异常如下:</p>
<pre><code>$ python3 test.py
Traceback (most recent call last):
  File &quot;test.py&quot;, line 6, in &lt;module&gt;
    raise UserNotFound(10010)
__main__.UserNotFound: User not found 10010
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python环境的搭建]]></title>
        <id>https://blog.qianqian.fun/post/python-huan-jing-de-da-jian/</id>
        <link href="https://blog.qianqian.fun/post/python-huan-jing-de-da-jian/">
        </link>
        <updated>2020-09-03T09:03:59.000Z</updated>
        <content type="html"><![CDATA[<p>本文就 python 开发环境的安装配置做一些说明。</p>
<h2 id="python-版本的选择">Python 版本的选择</h2>
<p>Python 采用了两段式的版本号 <code>&lt;Main&gt;.&lt;Subject&gt;</code> , 比如当前最新版本是 3.8。大的版本号分为 2.X 和 3.X。没有例外，应该全部选择 3.X 版本，2.X 已经走入了历史。</p>
<p>在 3.X 的众多版本中，其增加了如下的特性:</p>
<h2 id="python-30">Python 3.0</h2>
<p>• 函数注解（ Function Annotations ），可以对函数的参数和返回值进行注解。除了可以通过 <code>__annotations__</code>来访问这些注解外，没有其他更多的语义；<br>
• 仅限关键字形参（ Keyword-only arguments ），在函数形参中使用 <code>*</code> 来表示对应的形参必须使用关键字进行传递；<br>
• <code>nonlocal</code> 语句允许嵌套函数中的内部函数对外层函数作用域中的变量进行赋值；<br>
• 扩展的 Iterable 解包，比如 <code>(a, *rest, b) = range(5)；</code>；<br>
• 集合字面量，字典推导，新的八进制字面量，以 <code>b</code> 或 <code>B</code> 开头的字节串等等；</p>
<h2 id="python-31">Python 3.1</h2>
<p>• 有序字典 <code>collections.OrderedDict</code>；<br>
• 千位分隔符的格式说明符，比如 <code>'{0:,d}'.format(1234567) —&gt; '1,234,567'</code>；</p>
<h2 id="python-32">Python 3.2</h2>
<p>• Argparse 命令行解析模块；<br>
• 基于字典的日志配置 <code>logging.config.dictConfig()</code> 可以支持更灵活的配置方式；<br>
• concurrent.futures 模块 ；<br>
• 将字节码文件单独存储在 <code>__pycache__</code> 目录；</p>
<h2 id="python-33">Python 3.3</h2>
<p>• 虚拟环境工具 venv 和 pyvenv，后者 pyvenv 在 Python 3.6 中已弃用；<br>
• 隐式命名空间包；<br>
• OS 和 IO 异常的层次结构优化；<br>
• 委托给子生成器 <code>yield from</code>；<br>
• 允许禁用链式异常上下文的显示从而获取更干净的错误消息，比如 <code>raise AttributeError(attr) from None</code>；</p>
<h2 id="python-34">Python 3.4</h2>
<p>• pip 默认包含在 Python 的二进制安装程序中；<br>
• 异步 I/O 库 asyncio；<br>
• 支持枚举的模块 enum；<br>
• 面向对象的文件系统路径模块 pathlib；<br>
• 高级 I/O 复用模块 selectors；<br>
• 用于数学统计的模块 statistics；</p>
<h2 id="python-35">Python 3.5</h2>
<p>• 使用 async 和 await 语法实现原生协程 ；<br>
• 矩阵乘法运算符 <code>a @ b</code> ；<br>
• 类型标注支持的模块 <code>typing</code>；<br>
• 进一步扩展带有 <code>*</code> 的可迭代对象解包操作和带有 <code>**</code> 的字典解包操作；</p>
<h2 id="python-36">Python 3.6</h2>
<p>• 文字字符串插值，比如 <code>f&quot;He said his name is {name}.</code>&quot;；<br>
• 用于进一步增强类型标注的变量注释语法，比如 <code>names: List[str] = []</code>；<br>
• 异步生成器，允许在 <code>async / await</code> 中使用 <code>yield</code>；<br>
• 使用 <code>async for</code> 进行异步推导；<br>
• 用于生成高加密强度的随机数、密码、安全凭证的模块 <code>secrets</code>；</p>
<h2 id="python-37">Python 3.7</h2>
<p>• 延迟的类型标注求值；<br>
• 用于 Python 调试的内置 <code>breakpoint()</code> 函数；<br>
• 用于支持上下文变量的 <code>contextvars</code> 模块；<br>
• 声明数据类的 <code>dataclass()</code>，比如：</p>
<pre><code>@dataclass
class Person:
    name: str
    height: float
    weight: float = 130.0
p = Point('Bob', 175.5)
print(p)   # 输出 &quot;Person(name=Bob, y=175.5, z=130.0)&quot;
</code></pre>
<h2 id="python-38">Python 3.8</h2>
<p>• 赋值表达式语法 <code>:=</code>；<br>
• 仅限位置形参（ Positional-only parameters ），在函数形参中使用 <code>/</code> 来表示对应的形参必须使用位置进行传递。</p>
<h2 id="pip-的使用">Pip 的使用</h2>
<p>pip 是 Python 自带的一个包管理的工具，可以使用对项目中的依赖进行管理。就其基础的使用，如下实例:</p>
<pre><code>pip install &lt;package&gt; [package...]    ## 安装一个多多个包
pip install &lt;package&gt;==2.21.0         ## 安装指定版本的包
pip install --upgrade &lt;package&gt;       ## 升级指定的包
pip uninstall &lt;package&gt;               ## 卸载指定的包
pip list                              ## 打印已经安装的包的列表
pip freeze &gt; requirements.txt         ## 生成已经安装的软件包的列表，并重定向到 requirements.txt 文件中
pip install -r requirements.txt       ## 根据 requirements.txt 文件中的内容安装项目所需依赖
</code></pre>
<p>如果在使用 pip 的过程中出现安装超时的现象，可能是因为国外服务器在国内不稳定的缘故，可以换成豆瓣的镜像服务器下载资源，这样会快很多。编辑配置文件 <code>~/.pip/pip.conf</code> ， 内容如下:</p>
<pre><code>[global]
index-url = https://pypi.doubanio.com/simple
trusted-host = pypi.doubanio.com
</code></pre>
<h2 id="jupyter-notebooks">Jupyter Notebooks</h2>
<p>首先安装 Anaconda， 在其官方页面上下载安装包安装即可。安装的过程中，建议勾选，将可执行文件加入 PATH 的选项。</p>
<p>在 Anaconda 中已经包含了 Jupyter Notebooks ，直接在命令行下运行即可:</p>
<pre><code>jupyter notebook
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[终端复用器：tmux]]></title>
        <id>https://blog.qianqian.fun/post/zhong-duan-fu-yong-qi-tmux/</id>
        <link href="https://blog.qianqian.fun/post/zhong-duan-fu-yong-qi-tmux/">
        </link>
        <updated>2020-09-01T08:20:38.000Z</updated>
        <content type="html"><![CDATA[<p>使用 Linux，我们绝大多数的时候看到的都是黑漆漆的画面，是有一些枯燥的。但是，能不能在枯燥的画面中，玩些花样呢？<br>
比如说，我们模拟一个多窗口的环境，可以在多个窗口之间切换。再比如说，模拟一个多桌面的环境，不同的桌面包含不同的窗口。<br>
要实现上面这些功能，我们就需要清楚这篇文章的主角了 —— tmux。</p>
<h2 id="安装-tmux">安装 tmux</h2>
<p>如果是 CentOS：</p>
<pre><code>$ sudo yum install tmux
</code></pre>
<p>如果是 macOS:</p>
<pre><code>$ brew install tmux
</code></pre>
<h2 id="创建和销毁会话">创建和销毁会话</h2>
<p>在 tmux 中，有一个 Session 的概念，和桌面是一样的意思。一个 Session 可以包含多个窗口( Window ）。如何创建 Session 呢？</p>
<pre><code>$ tmux new -s &lt;Session Name&gt;
</code></pre>
<p>查看已经创建的 Session：</p>
<pre><code>$ tmux ls
</code></pre>
<p>进入已经创建的 Session：</p>
<pre><code>$ tmux a -t &lt;Session Name&gt;
</code></pre>
<p>如果要临时退出会话, 使用 <code>ctrl+b</code> ，然后按下 <code>d</code> 。<br>
如果要销毁会话，使用 <code>ctrl+b</code> ，然后按下 <code>:</code> 进入命令模式，输入命令: <code>kill-session</code> 。</p>
<h2 id="模拟多窗口的环境">模拟多窗口的环境</h2>
<p>窗口是基于 Session 的，所以需要先进入一个 Session。然后创建窗口，需要使用 <code>Ctrl + b</code> , 然后按下  <code>c</code> 键:<br>
<img src="https://blog.qianqian.fun/post-images/1599553600554.png" alt="" loading="lazy"><br>
我们看到下面显示着一行绿色的状态栏，内容如下:<br>
<img src="https://blog.qianqian.fun/post-images/1599553606953.png" alt="" loading="lazy"><br>
你看到上面切换的窗口序号了吗？我们可以根据这个切换窗口，比如要切换到第一个窗口，就可以按下组合键: <code>Ctrl + b</code> , 然后按下 <code>1</code> ，这里的 <code>1</code> 就是窗口的序号。<br>
我们看到，起 Window 的默认命令规则是采用了命令提示符，如果要重命名呢？ <code>Ctrl+B</code> ,然后按下 <code>,</code> 。<br>
如果我们要暂停这个会话，回到最初的界面呢？ <code>Ctrl + B</code> ，然后按下 <code>d</code> 。</p>
<h2 id="分割窗口">分割窗口</h2>
<p>一个窗口可以切换成多个 Pane(面板)。使用 <code>Ctrl+B</code> ，然后按下 <code>&quot;</code> 可以创建水平面板，按下 <code>%</code> 可以创建垂直面板。<br>
如果需要切换全屏，可以使用 <code>Ctrl+B</code> ,然后按下 <code>z</code> 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个完整的前后端应用（Flask）]]></title>
        <id>https://blog.qianqian.fun/post/yi-ge-wan-zheng-de-qian-hou-duan-ying-yong-flask/</id>
        <link href="https://blog.qianqian.fun/post/yi-ge-wan-zheng-de-qian-hou-duan-ying-yong-flask/">
        </link>
        <updated>2020-08-25T10:07:17.000Z</updated>
        <content type="html"><![CDATA[<p>我一直认为，不管是前端，还是后台，或是测试，都应该去做一个完整的包含前后端的应用。只有这样，你才能清楚明白前后端交互的逻辑，只有这样，技术生涯才算完整(如果愿意它更完整，也可以玩玩测试、运维等角色扮演)。</p>
<p>这篇文档的目的，就是用一个最小的 DEMO 来完成一个前后端对接的过程。我选择了发表说说这样一个谁都知道，谁都体验过的功能。</p>
<h2 id="技术选型">技术选型</h2>
<p>在开始一个项目之前，有一项工作叫做技术选型，即需要用什么技术去完成这个项目。没有统一的标准，但有一些思考维度:</p>
<p>• 你选择的技术你是否能够熟练掌握应用<br>
• 你选择的技术你团队中的其他人是否熟练掌握应用<br>
• 你选择的技术是否适合你将要开始的项目<br>
• 选择这项技术你所需的成本，包括用人成本、学习成本、时间成本以及维护成本等<br>
• 你的老板、同事、领导、客户等是否喜欢<br>
• 技术本身是否成熟、社区是否活跃、官方或第三方是否仍旧维护等<br>
• 其他一切你有所顾忌的因素</p>
<p>在这个应用中，我选择了小程序作为前端，而非 APP 或者传统的 Web 技术栈(JavaScript、HTML、CSS)。原因是，小程序相对其他的技术，环境容易布置、文档齐全、学习门槛比较低以及比较贴近实际。</p>
<p>在这个应用中，我选择了 Python + Flask 作为后端技术，原因是这系列文章就是专门讲 Python 的和 Flask 的。这个应用本身，也是为了巩固大家对 Python + Flask 的基础知识的。</p>
<h2 id="业务说明">业务说明</h2>
<p>这个应用就只有一个页面，当我们进入这个页面的时候，会讲历史的说说全部展示在列表中，此外，我们也可以在文本框中输入新的说说，然后点击【发表说说】按钮发布说说内容，发布之后，列表中出现新的说说，并且清空文本框中的说说。原型图如下:</p>
<figure data-type="image" tabindex="1"><img src="https://blog.qianqian.fun/post-images/1599559804873.png" alt="" loading="lazy"></figure>
<h2 id="前端业务编写">前端业务编写</h2>
<p>首先，我们需要先创建一个新的页面，命名为 index, 在 pages 目录下。 在小程序里一个页面有三个文件:</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>作用描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>index.js</td>
<td>用来书写业务逻辑</td>
</tr>
<tr>
<td>index.wxml</td>
<td>用来书写页面元素骨架</td>
</tr>
<tr>
<td>index.wxss</td>
<td>用来书写页面样式</td>
</tr>
</tbody>
</table>
<p>这个应用中，暂时不包括 index.wxss 文件的代码，为了不增加编码的复杂度。所以我们写的真实应用可能还不如原型图好看。</p>
<p>需要注意的是，每个创建的页面都要在 app.json 中的 <code>pages</code> 中注册, 使用小程序开发者工具中的新建 Page 按钮会自动注册:</p>
<pre><code>{
  &quot;pages&quot;: [
    &quot;pages/index&quot;
  ]
  ......省略
}
</code></pre>
<p>前端业务的编写主要分为三个部分:</p>
<ol>
<li>页面的骨架，这是最先编写的内容，即页面上有什么内容？文案、图片、按钮？</li>
<li>页面的样式，就是对页面的美化，这部分也包括动画交互</li>
<li>页面的逻辑，包括与用户的交互和与服务端的交互</li>
</ol>
<h2 id="编写页面元素骨架">编写页面元素骨架</h2>
<p>首先我们要编写页面元素的骨架, 即 index.wxml 文件, 代码如下:</p>
<pre><code>&lt;view&gt;
    &lt;input placeholder=&quot;请输入你想说的&quot; bindinput=&quot;onChange&quot; value=&quot;{{say}}&quot; /&gt;
    &lt;button bindtap=&quot;onTap&quot;&gt;发表说说&lt;/button&gt;
    &lt;view&gt;你的说说列表:&lt;/view&gt;
    &lt;view wx:for=&quot;{{list}}&quot;&gt;
      {{item}}
    &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<p>小程序是组件化编程，所以页面上的元素都是一个个的组件。上面的代码中，包含如下组件:</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>view</td>
<td>视图组件，可以包含其他任何组件，也作为最外层组件。</td>
</tr>
<tr>
<td>input</td>
<td>输入框组件。接收文本输入。</td>
</tr>
<tr>
<td>button</td>
<td>按钮组件。一般用于触发用户的触摸屏幕的事件，然后执行某些操作。</td>
</tr>
</tbody>
</table>
<p>可以看得出，为了不增加编码复杂度。我们只用了三个小程序官方提供的组件。</p>
<p>在上面的代码中，有几种特殊的写法讲解一下，但是这并不是专门讲小程序开发的教程，所以不会讲得非常细致，点到为止。</p>
<p>在组件中，可以包含一些组件地属性, 用来改变组件地外观样式或者行为。比如下面这行代码，我们使用 <code>placeholder</code> 属性来改变当用户没有输入地时候地提示文案: 请输入你想说的。</p>
<pre><code>&lt;input placeholder=&quot;请输入你想说的&quot; /&gt;
</code></pre>
<p>另外，我们还有一个属性地值比较奇怪, 在 input 组件中，我们对 value 组件赋值为 <code>{{say}}</code> ，这说明 say 是一个变量，而不是一个类似于 &quot;请输入你想说的&quot; 这样地字面量(写死地值)。</p>
<pre><code>&lt;input placeholder=&quot;请输入你想说的&quot; value=&quot;{{say}}&quot; /&gt;
</code></pre>
<p>还有一些属性比较奇怪，属性名都是 <code>bind</code>开头, 这些属性是事件的绑定。<strong>什么是事件呢？比如用户单击了某个按钮，微信小程序需要通知我们的程序，用户点击了这件事情，以此出发我们对这个事件预定的操作</strong>。</p>
<pre><code>&lt;input bindinput=&quot;onChange&quot; /&gt;
</code></pre>
<p>这个组件中有一个事件，名字叫做 <code>bindinput</code> , 其含义是当用户输入的时候就会触发这个事件，然后微信小程序会去调用我们预定的方法 <code>onChange</code>。</p>
<p>类似的还有下面这个 <code>button</code> 组件的 <code>ontap</code> 事件，当用户触摸这个按钮，然后就会出发这个事件，然后微信小程序会去调用我们预定的方法 <code>onTap</code> 。</p>
<pre><code>&lt;button bindtap=&quot;onTap&quot;&gt;发表说说&lt;/button&gt;
</code></pre>
<p>对于说说的列表，我们不可能知道它到底有多少数量，所以我们应该使用循环语句讲其循环出来。即服务端返回多少，我们就展示多少。为了降低程序的复杂度，这里并不涉及到分页:</p>
<pre><code>&lt;view wx:for=&quot;{{list}}&quot;{{item}}&lt;/view&gt;
</code></pre>
<p>这当中的 <code>item</code> 是微信小程序内置的变量，只用在循环块中( <code>&lt;view wx:for=&quot;{{list}}&quot;&gt;...&lt;/view&gt;</code> ，即省略号所在的位置)。</p>
<h2 id="编写页面逻辑">编写页面逻辑</h2>
<p>以前，我的编程老师在课上说，要写一个程序首先应该把这个程序中的变量都罗列出来。如果你把变量都罗列出来了，那么这个程序也就完成一半了。</p>
<p>那时候，我并不是很理解这句话，一个程序那么复杂，为什么定义变量就完成一半了。后来知道了，因为定义了所有的变量，你也就知道程序改怎么写了。</p>
<p>所以，我们要完成页面逻辑的编写，首先要分析页面，定义出页面逻辑中需要的变量。通过分析，我们需要两个变量，如下:</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>变量类型</th>
<th>作用描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>say</td>
<td>String</td>
<td>用来保存我们在 input 组件中输入的说说文本</td>
</tr>
<tr>
<td>list</td>
<td>Array</td>
<td>用来保存我们 list 中的数据</td>
</tr>
</tbody>
</table>
<p>在 index.js  文件中，加入变量定义的代码：</p>
<pre><code>Page({
  data: {
    say: '',
    list: [],
  }
})
</code></pre>
<p>我们已经定义了变量了，并且为这两个变量赋予了初始值。这里要额外说一说，小程序采用数据驱动编程的思想，即我们只需要定义变量，然后再 JS 中更改变量的值，页面中使用了这些变量的元素将会自动更新变量的值。</p>
<p>下面的讲解就描述了这个过程。</p>
<p>上面我们已经定义了两个变量，分别是 <code>say</code> 和 <code>list</code> ,那么这两个变量什么时候会改变呢？当然是当某些事件被触发的时候:</p>
<p>• 页面加载的时候，我们会从后端请求说说列表的数据，然后改变 <code>list</code> 的值，当我们改变了 <code>list</code> 的值，小程序会自动更新页面中的列表，这就是数据驱动。</p>
<p>• 当用户再 input 组件中输入文本的时候，会触发 input 组件的 bindinput 事件，在其 onChange 方法中，我们会更新 say 的值</p>
<p>• 当用户触摸“发表说说”按钮的时候，会触发 button 组件的 bindtap 事件，在其 onTap 方法中，我们会改变 list 的值，将 say 这变量中保存的文本加入到 list 数组中。为了让下一次用户输入说说，免去删除之前的说说的操作，我们会自动清楚 say 的值，文本框中的值也会由微信小程序自动清除。</p>
<p>所以，我们的页面逻辑其实也是围绕着这两个变量展开的，要由我们去完成这些会改变变量的事件，然后小程序会自动重新渲染我们的页面，使得我们的页面可以呈现最新的数据。</p>
<p>首先，我们要来写 input 组件的 onChange 事件, 在这个事件中，我们只要完成一件事情就可以了，就是将用户在文本框中输入的值，赋值给 <code>say</code> 这个变量，在小程序中，如果要为变量赋值，可以使用 <code>this.setData</code> 方法:</p>
<pre><code>Page({
  onChange: function (event) {
    // 需要说明的是，小程序会主动调用这个方法，并传递 event 这个参数，当中包含了事件相关的数据
    this.setData({
      // event 变量中，我们之关系 event.detail.value 这个值，这保存着文本框中用户的内容
      // 不要问我怎么知道是保存在 event.detail.value 中的，是看微信官方文档知道的
      say: event.detail.value
    })
  },
})
</code></pre>
<p>接着，我们要来完成当用户触摸“发表说说”按钮时，触发 Button 按钮的 bindtap 事件，微信会调用 <code>onTap</code> 方法，在这个方法中，我要要完成四件事情:</p>
<ol>
<li>检查说说内容是否为空，因为输入空的说说没有任何意义</li>
<li>往说说列表中加入新的说说，其实就是更改 list 变量的值</li>
<li>发送说说给服务端，因为说说最终要保存到数据库，否则下次进来就数据就丢了</li>
<li>清空说说文本框的内容，其实是将 say 的值改为 '' 空字符串</li>
</ol>
<p>详细的代码如下:</p>
<pre><code>// 检查说说是否为空
if (this.data.say === '') {
  wx.showToast({
    title: '说说不能为空哦'
  })
}
// 往说说的列表中添加新的说说
this.data.list.push(this.data.say)
this.setData({
  list: this.data.list
})
// 发送说说给服务端，保存说说到数据库
wx.request({
  url: 'http://116.85.30.153:5000/list/save',
  method: 'post',
  data: {
    say: this.data.say
  }
 })
// 清空说受输入框
this.setData({
  say: ''
})
</code></pre>
<p>最后，我们要完成页面的 onLoad 方法，当页面加载的时候，微信小程序会执行这个方法。所以我们要在这个方法中，去请求服务端，获取数据库中保存的数据，并加载到列表中(改变 list 的值)：</p>
<pre><code>onLoad: function (options) {
    wx.request({
      url: &quot;http://116.85.30.153:5000/list&quot;,
      success: (response) =&gt; {
          this.setData({
            list: response.data
          })
      }
    })
}
</code></pre>
<p>关于上面 () =&gt; {} 这样的写法叫做箭头函数，可以参考文本 附录: 箭头函数 章节。</p>
<p>到此为止，我们就完成了整个页面逻辑的编写了。实际上，再怎么复杂的功能，也都是由这些逻辑堆叠的。</p>
<h2 id="附录-箭头函数">附录: 箭头函数</h2>
<p>这里需要说明的是，上文中 success 的函数采用了 JavaScript ES6 规范中的语法，箭头函数。这个函数也可以换一种写法:</p>
<pre><code>onLoad: function (options) {
  // 因为 this 的作用域是变化的，不能在 success 的回调函数中使用，所以给 that 赋值保存其内容
    const that = this    
    wx.request({
      url: &quot;http://116.85.30.153:5000/list&quot;,
      success: function (response) {
          // 这里就不能使用 this 了,因为这里的 this 的指向是 function () {} 本身，所以使用事先保存的 that
          // 因为 that 才具有 setData 这个方法
          that.setData({
            list: response.data
          })
      }
    })
}
</code></pre>
<p>你看，上面这种写法是不是很麻烦？在 JavaScript 语言中， this 它的指向是一个不容易搞懂的问题，经常会因此出错。所以，在新的规范中，创造了箭头函数这样的写法，功能上和普通的函数是一样的，只是它不存在 this 指向问题，可以直接在 success 回调函数中使用 this 变量，而不用事先将 this 赋值给一个变量(示例中使用 that）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python字符串详解]]></title>
        <id>https://blog.qianqian.fun/post/python-zi-fu-chuan-xiang-jie/</id>
        <link href="https://blog.qianqian.fun/post/python-zi-fu-chuan-xiang-jie/">
        </link>
        <updated>2020-08-25T09:54:56.000Z</updated>
        <content type="html"><![CDATA[<p>什么是字符串？其实就是字符，区分于其他的类型，比如说数字。下面展示的都是一些字符串:</p>
<pre><code>str1 = 'Hello World'
str2 = '123'
str3 = &quot;Let's go to moon&quot;
str4 = &quot;&quot;&quot;
   窗前明月光
   怀是滴上霜
&quot;&quot;&quot;
str5 = '''
   Left's go to moon
'''
</code></pre>
<h2 id="多种引号之间的区别">多种引号之间的区别</h2>
<p>在 Python 中，使用引号来包裹字符串内容。可以使用单引号、双引号以及像上面 <code>str4</code> 和 <code>str5</code> 那样使用连续的三个单引号或三个双引号来表示多行文本。</p>
<p>注意：这些引号都应该在英文输入法下输入，都是英文的引号，而不是中文。</p>
<p>那么单引号和双引号有什么区别呢？就如变量 <code>str3</code> 一样，双引号可以包含转义字符，比如 <code>'</code> 。如果在单引号中出现转义字符，则需要使用转移符号 <code>\</code> 进行转义，否则程序将出错:</p>
<pre><code>str1 = 'Let's go to moon'   # 这样写是错误的
str2 = 'Let\'s go to moon'  # 使用转义符号转义是正确的
str3 = &quot;Let's go to moon'   # 双引号不需要明确使用转义符号进行转义
</code></pre>
<p>通常这种情况，推荐使用双引号，看起来比较舒服，也无需关系转义字符导致的程序异常。</p>
<p>三引号又分为三个单引号和三个双引号，它们都是用来表示多行文本，并没有区别。也就是说，两种方式都可以使用。</p>
<p>多行文本用在，单行文本太长的情况下，或者需要换行的情况。比如我需要用一个字符串变量来包含一段 Python 代码:</p>
<pre><code>code = '''
from flask import Flask
app = Flask(__name__)
@app.route('/')
def index():
    return 'Hello World'
'''
# 引号并不要求单独写一行，但是习惯上单独写一行，较为直观。
</code></pre>
<p>这种情况下，就很适合使用多行文本。Python 会在每一行末尾加入 <code>\n</code> 转义字符，表示换行。</p>
<h2 id="什么是转义字符">什么是转义字符</h2>
<p>什么是转义字符？可以理解成是特殊的字符。那么它们特殊在哪里呢？</p>
<p><strong>其中一部分的转义字符是为了表示看不见的字符</strong>。我们很自然的以为，在键盘上敲击的每一个键都可以在屏幕上显示出起对应的字符。但实际上有一些键同样输出了字符，但在屏幕上并没有显示。比如说我们上面中出现的 <code>\n</code> 换行符。虽然看不见，但必须使用一个字符告诉计算机，我回车了。</p>
<p><strong>还有一类是在编程语言中，已经被语言本身使用并表示特殊含义的字符</strong>。比如说引号，在 Python 中使用一对引号来表示字符串。这时候如果在一对双引号中再次输入一个双引号，就会导致程序没有办法判断哪里是字符串的开始、哪里是字符串的结束。</p>
<p>还有一些其他的作用，但是没有必要去死记硬背。记住几个常用的就好了，比如说 <code>\n</code> 表示换行、 <code>\r</code> 表示回车、 <code>\t</code> 表示制表符(Tab键)。</p>
<p>转义符号 <code>\</code> 本身也是转义字符，如果我希望它能在字符串中输出，那么也应该对它进行转义，比如:</p>
<pre><code>print('转义符号: \\')
</code></pre>
<p>另外，我们也可以通过原始字符串(Raw String)的方式来表达:</p>
<pre><code>path = r'C:\Windows\system64\etc\derver\etc\hosts'
print(path)
</code></pre>
<h2 id="字符串的运算">字符串的运算</h2>
<p>我们在生活中，经常会对数值进行运算，那么什么叫做对字符串运算呢？我举一个例子：</p>
<pre><code>老板: 这个东西今天能做完吗？
我: 不能！
老板: 把不字去掉！
</code></pre>
<p>对，这就是字符串的运算之一，对字符串内容的剪切。除此之外，我们还经常回对字符串内容进行拼接、替换等操作。</p>
<h3 id="字符串的拼接">字符串的拼接:</h3>
<pre><code>print('Hello' + ' ' + 'World')
</code></pre>
<p>上面是字符串的“加法运算”，表示对字符串进行拼接。那么如果是乘法呢？</p>
<pre><code>print('Hello' * 3)  # HelloHelloHello
print('Hello' * 'World') # 语法错误
</code></pre>
<p>字符串(String)本质上是一串字符(Char)，是 Char 的列表。所以，我们也可以使用列表的形式来访问字符串:</p>
<pre><code>print('Hello'[0]) # H
print('Hello'[-1])  # o
print('Hello'[0:3]) # Hel
print('Hello'[0:-1]) # Hell
print('Hello'[1:])   # ello, 截取到末尾
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux常用的命令-文件和磁盘]]></title>
        <id>https://blog.qianqian.fun/post/linux-chang-yong-de-ming-ling-wen-jian-he-ci-pan/</id>
        <link href="https://blog.qianqian.fun/post/linux-chang-yong-de-ming-ling-wen-jian-he-ci-pan/">
        </link>
        <updated>2020-08-20T07:57:09.000Z</updated>
        <content type="html"><![CDATA[<p>这一篇文档记录了一些有关于文件和磁盘的命令。</p>
<h2 id="linux-文件系统">Linux 文件系统</h2>
<p>在了解这些命令之前，我们需要先了解 Linux 文件系统。在 Windows 中，我们的磁盘会被划分为多个逻辑磁盘:<br>
<img src="https://blog.qianqian.fun/post-images/1599553062832.png" alt="" loading="lazy"><br>
但是在 Linux 上，和 Windows 是完全不一样，没有 A盘、B盘、C盘的概念，有的只是一棵目录树。<br>
<img src="https://blog.qianqian.fun/post-images/1599553021390.jpg" alt="" loading="lazy"><br>
那么这么多的目录他们都是干什么用的呢？下面这张表格可以回答这个问题:</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>bin</td>
<td>重要的可执行文件、shell 命令</td>
</tr>
<tr>
<td>boot</td>
<td>引导器配置文件、内核等</td>
</tr>
<tr>
<td>dev</td>
<td>设备文件</td>
</tr>
<tr>
<td>etc</td>
<td>系统专有的配置文件</td>
</tr>
<tr>
<td>lib</td>
<td>重要的共享库和内核模块</td>
</tr>
<tr>
<td>media</td>
<td>可移动设备挂载点</td>
</tr>
<tr>
<td>mnt</td>
<td>其他文件系统的临时挂载点</td>
</tr>
<tr>
<td>opt</td>
<td>附加应用软件包</td>
</tr>
<tr>
<td>sbin</td>
<td>重要的系统可执行文件</td>
</tr>
<tr>
<td>tmp</td>
<td>临时文件</td>
</tr>
<tr>
<td>usr</td>
<td>文件系统的第三层</td>
</tr>
<tr>
<td>var</td>
<td>可变数据</td>
</tr>
</tbody>
</table>
<h2 id="find-查找文件">find-查找文件</h2>
<p>比如我们需要查找名为 <code>passwd</code> 的文件:</p>
<pre><code>$ sudo find / -name passwd   ## 对应的格式： find [path...] -name [pattern]
</code></pre>
<p>我们可以指定文件类型，比如说指定为目录:</p>
<pre><code>$ sudo find / -type d -name etc
/sys/firmware/qemu_fw_cfg/by_name/etc
/etc
...省略
</code></pre>
<p>文件的类型如下表所示:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>文件夹</td>
</tr>
<tr>
<td>f</td>
<td>普通文件</td>
</tr>
<tr>
<td>l</td>
<td>符号连接文件</td>
</tr>
<tr>
<td>b</td>
<td>块设备</td>
</tr>
<tr>
<td>c</td>
<td>字符设备</td>
</tr>
<tr>
<td>p</td>
<td>管道文件</td>
</tr>
<tr>
<td>s</td>
<td>socket 套接字</td>
</tr>
</tbody>
</table>
<p>命令当中也可以指定通配符, 比如我要搜索 <code>.jpg</code> 结尾的文件:</p>
<pre><code>$ sudo find / -name '*.jpg'
/usr/share/backgrounds/morning.jpg
/usr/share/backgrounds/night.jpg
...省略
</code></pre>
<p>我们还可以按照文件的大小来搜索:</p>
<pre><code>$ sudo find / -type f -size +40M
/var/lib/rpm/Packages
/usr/lib/locale/locale-archive
/usr/local/sgd/ags/monitor/log/INFO.log
...省略
</code></pre>
<h2 id="du和df-磁盘占用">du和df-磁盘占用</h2>
<p>du 命令，全称是 disk usage, 用来展示磁盘使用量的统计信息。</p>
<pre><code>## 统计当前目录下的磁盘占用
## s 表示每一个给定的参数计算其磁盘使用量
## h 表示使用人类可以阅读的单位显示，比如 KB\MB\GB
$ du -sh .     
</code></pre>
<p>df 命令, 侧重在文件系统级别的磁盘占用，而 du 则是测试中在文件夹和文件的磁盘占用。</p>
<pre><code>$ df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/vda1        40G  2.2G   38G   6% /
devtmpfs        1.9G     0  1.9G   0% /dev
tmpfs           1.9G     0  1.9G   0% /dev/shm
tmpfs           1.9G   33M  1.9G   2% /run
...省略
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[近期学习的Linux命令]]></title>
        <id>https://blog.qianqian.fun/post/jin-qi-xue-xi-de-linux-ming-ling/</id>
        <link href="https://blog.qianqian.fun/post/jin-qi-xue-xi-de-linux-ming-ling/">
        </link>
        <updated>2020-07-25T08:18:36.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>mkdir 创建文件夹<br>
<code>mkdir aa</code></li>
<li>touch 创建文件<br>
<code>touch a.txt</code></li>
<li>cd 切换目录<br>
<code>cd home</code><br>
<code>cd /</code><br>
<code>cd ~</code></li>
<li>cat 查看文件内容<br>
<code>cat a.txt</code></li>
<li>登陆服务器<br>
<code>ssh root@47.100.18.25</code></li>
<li>tail 查看文件尾部内容<br>
<code>tail -n1 /etc/passwd</code></li>
<li>ls 显示指定工作目录下的内容及属性信息<br>
<code>sudo ls -al /etc/skel</code><br>
-a	显示所有文件及目录 (包括以“.”开头的隐藏文件)<br>
-l	使用长格式列出文件及目录信息</li>
<li>echo 输出字符串或提取Shell变量的值<br>
<code>echo '' alias CD_TEST='cd ~/test' &quot; &gt;&gt; ~/.bashrc</code><br>
追加内容  alias CD_TEST='cd ~/test'  到bashrc中</li>
<li>alias 设置命令别名<br>
<code>alias -p</code><br>
查看系统已经设置的别名</li>
<li>su 切换用户<br>
<code>su - test</code><br>
切换到 wq 用户，并改变 wq 用户的环境变量，- 表示切换用户的环境变量</li>
<li>useradd 创建用户<br>
<code>useradd -m test</code></li>
<li><code>sudo passwd test</code><br>
设置用户密码</li>
<li>userdel 删除用户<br>
<code>sudo userdel -r test</code><br>
userdel 可删除etc/passwd 下的用户信息，但不会删除家目录<br>
-r 可以删除相关的目录信息</li>
<li>创建新用户并加入新创建的组<br>
<code>sudo useradd test_user</code> 创建新用户<br>
<code>sudo groupadd test_group</code> 创建新的用户组<br>
<code>sudo usermod -G test_group test_user</code> 将新用户加入新的组<br>
<code>sudo groupmod -n test_mod_group test_group</code>  将test_group 组名<br>
改为test_mod_group</li>
<li>查看文件权限<br>
<code>ls -la test_file</code></li>
<li>chmod 分配权限<br>
<code>sudo chmod u-r test_file</code><br>
u -文件所属者<br>
g -文件的所属组<br>
o -其他用户</li>
<li>查看发行版的详细信息<br>
<code>lsb_release -a</code></li>
<li>查看系统发行版本<br>
<code>less /etc/issue</code> q 退出<br>
<code>cat /etc/issue</code></li>
<li>查看软件版本信息<br>
<code>python --version</code></li>
<li>查看是否安装了某个软件包<br>
<code>sudo rpm -qa python</code></li>
<li>卸载已经安装的软件包<br>
<code>sudo rpm -e python --nodeps</code>  --nodeps 避免去检查相关的依赖环境导致不能卸载</li>
<li>安装软件<br>
<code>sudo yum install python36 -y</code></li>
<li>服务器重装后keys改了终端连接不上的方法<br>
<code>ssh-keygen -R</code> 在本机执行此命令即可</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正义不会缺席]]></title>
        <id>https://blog.qianqian.fun/post/zheng-yi-bu-hui-que-xi/</id>
        <link href="https://blog.qianqian.fun/post/zheng-yi-bu-hui-que-xi/">
        </link>
        <updated>2020-07-25T06:59:54.000Z</updated>
        <content type="html"><![CDATA[<p>最近关于来女士的案子在网上广为流传，虽然我们都希望她平安无事，但天不遂人愿。从出事到今天警方发布案子通告，真相虽然已经浮出水面，但是相信很多人都想不通，为什么枕边人竟就是那个凶手，当然我也没想明白，为什么好好的日子过成了这样。十年修得同船渡，百年修得共枕眠，原本应该相亲相爱携手渡百年的夫妻却以如今这段惨剧收场了，可怜他们那小女儿，这段经历在她心里也许永远都挥之不去。</p>
<p>究其原因竟然只是因为家庭琐事意见不合，在此我真的想说，广大同胞们，凡事都是可以心平气和的讨论的，遇事要及时沟通，不要积在心里。不要走极端，走极端就容易出问题，以上就是活生生的例子啊。有什么事情过不去非要以这种方式来解决呢。最后发生这种事的原因只是一个导火线，也许就是因为没有及时沟通，有些事日积月累，就导致了这样的恶果。那个作为凶手的丈夫，他但凡想着点家庭，孩子，及时沟通的话，也不会生出犯罪的想法，更不会酿成这样的惨案。</p>
<p>事已至此，我就希望来女士能安息，愿天堂没有恶魔。我希望凶手能诚心悔过，承担应有的责任，我更希望他们的小女儿能忘记这段过去，走出这个阴影，阳光快乐的生活。我还想说不要想着犯罪，无论你有多高明，我们的人民警察一定能抓住你，只不过事时间问题。要记住，天网恢恢，疏而不漏，正义也许会迟到，但是永远不会缺席！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用的命令-基础]]></title>
        <id>https://blog.qianqian.fun/post/linux-chang-yong-de-ming-ling-ji-chu/</id>
        <link href="https://blog.qianqian.fun/post/linux-chang-yong-de-ming-ling-ji-chu/">
        </link>
        <updated>2020-07-06T07:21:57.000Z</updated>
        <content type="html"><![CDATA[<p>这一篇文档记录了一些常用的命令，以备学习查询之用。并将这些命令进行分类整理，方便检索。</p>
<h2 id="export-环境变量">export-环境变量</h2>
<p>你知道什么是环境变量吗？如果你不知道，你应该运行这条命令：</p>
<pre><code>$ export
declare -x HISTCONTROL=&quot;ignoredups&quot;
declare -x HISTSIZE=&quot;1000&quot;
declare -x HOME=&quot;/home/dc2-user&quot;
declare -x HOSTNAME=&quot;10-255-0-106&quot;
declare -x LANG=&quot;en_US.UTF-8&quot;
declare -x LESSOPEN=&quot;||/usr/bin/lesspipe.sh %s&quot;
declare -x LOGNAME=&quot;dc2-user&quot;
......省略
</code></pre>
<p>是的，使用 <code>export</code> 可以将当前环境下的变量全部打印在屏幕上。所以说，环境变量的本质还是变量，只是这些变量会随着环境的变化而变化，比如登录用户发生了变化。<br>
有没有想过为什么会有环境变量的存在？<br>
举个例子，我写了一个程序，它需要调用 Java 程序去执行某些事情。但是很快我就遇到了问题，在我的机器上程序运行没有问题，换了朋友的机器就运行不了了。原来是因为朋友的机器上没有安装 Java。他安装了 Java，还是运行不了。为什么？原来是因为它安装的目录和我不一样。<br>
通过这个例子，你应该明白了吧？有些因素是和环境相关的，这些环境相关的因素是软件的开发者在软件的编写的时候无法预知的。这就需要环境本身来告诉我。还是以上面这个例子继续说:<br>
在安装 Java 程序的时候，需要设置 Java 程序的环境变量，比如说 JAVA_HOME 。这样其他的程序在调用 Java 的时候就知道 Java 安装在哪里了。<br>
除了 Java 安装在哪里，还需要知道当前登录的用户名是什么？当前用户的 Home 目录在哪里？临时目录在哪里？等等等等。 这就是环境变量存在意义：告诉环境中运行的软件，一些在他们的开发者开发的时候不能预测的因素 。<br>
除此之外， <code>export</code> 还可以设置环境变量，如下示例:</p>
<pre><code>$ export my_var=my_var_value
$ echo $my_var   ## my_var_value
</code></pre>
<h2 id="history-历史命令">history-历史命令</h2>
<p>使用 <code>history</code> 命令可以查看我们输入的命令的历史:</p>
<pre><code>$ history
    1  python --version
    2  pip --version
    3  sudo yum install python3
</code></pre>
<p>默认情况下，使用 <code>history</code> 命令输出的每一行都是由序号以及命令组成的，如果我想改变这个格式呢？可以通过设置环境变量的方式，改变 <code>history</code>  命令输入的格式，比如加入命令的执行时间:</p>
<pre><code>$ export HISTTIMEFORMAT='%F %T '
$ history
    1  2020-07-13 22:29:04 python --version
    2  2020-07-13 22:29:04 pip --version
    3  2020-07-13 22:29:04 sudo yum install python3
</code></pre>
<p>你有没有发现，这几条命令的执行时间都是一样的？是因为这些命令执行的时候，并没有通过设置 <code>HISTTIMEFORMAT</code> 环境变量的方式开启“记录命令执行时间戳”的功能，所以就以其最近记录的时间戳的命令为准。</p>
<pre><code>$ history | tail -n 3
  165  2020-07-13 22:41:19 cat
  166  2020-07-13 22:41:26 echo ok
  167  2020-07-13 22:41:33 history | tail -n 3
</code></pre>
<p>然后我们现在在执行几条命令， 发现时间都不一样了，对吧。另外，我们还可以设置记录历史命令的数量:</p>
<pre><code> $ echo $HISTSIZE     ## 默认为 1000
 $ export $HISTSIZE=2000
</code></pre>
<p>如果要清空历史记录，可以使用 <code>history -c</code>删除内存中记录的命令。但是，实际上命令是记录在 <code>.bash_history</code> 这个文件中的，所以真正要删除命令，避免下次登录的时候重新加载该文件中的内容，可以使用 <code>history -w</code>命令。<br>
下表记录了，<code>history</code> 命令相关的环境变量:</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HISTCONTROL=erasedups</td>
<td>清除整个命令中的重复条目</td>
</tr>
<tr>
<td>HISTCONTROL=ignoredups</td>
<td>忽略记录命令历史中连续重复的命令</td>
</tr>
<tr>
<td>HISTCONTROL=ignorespace</td>
<td>忽略记录空格开始的命令</td>
</tr>
<tr>
<td>HISTCONTROL=ignoreboth</td>
<td>等价于 ignoredups 和 ignorespace</td>
</tr>
</tbody>
</table>
<p>如果要执行上一条命令，可以使用 <code>!!</code> , 如果要执行历史命令中的某一条命令，可以使用 <code>!&lt;序号&gt;</code> :</p>
<pre><code>$ !!         ## 执行上一条命令
$ history
    1  clear
    2  history
    3  cat ~/.bash_history
$ !3
</code></pre>
<h2 id="date-系统时间">date-系统时间</h2>
<p>在 Windows 上，我们可以通过查看状态栏，得知现在是什么时候了。而在 Linux 中，我们通过什么命令来知晓时间呢？——  <code>date</code> 。</p>
<pre><code>$ date
Tue Jul 14 13:25:30 CST 2020
如果是 CentOS/7 发行版，我们可以使用下面这个命令:
$ timedatectl
      Local time: Tue 2020-07-14 13:30:18 CST     ## 本地时间
  Universal time: Tue 2020-07-14 05:30:18 UTC     ## 世界协调时间
        RTC time: Tue 2020-07-14 05:30:18         ## RTC 芯片的时间
       Time zone: Asia/Shanghai (CST, +0800)      ## 时区
  .....省略
</code></pre>
<p>如果时区不对，对造成各类服务时间错误，与第三方对接授权错误，所以应该使用如下命令调整时区：</p>
<pre><code>$ timedatectl set-timezone &quot;Asia/Shanghai&quot;   # 设置时区
$ timedatectl list-timezones    # 查看所有时区
</code></pre>
<p>注意： 建议将时区全部设置为上海，因为一般大型的互联网企业都在上海设置数据中心。在与这些服务商通信的时候，可以尽可能避免因为细小的时间差距从而导致的错误。<br>
另外，受限于硬件的精准度，所以我们需要启动 NTP 时间同步服务，与授时服务器定时同步时间，以保证时间的准确:</p>
<pre><code>$ timedatectl set-ntp true
</code></pre>
<h2 id="time-你的程序跑的有多快">time-你的程序跑的有多快</h2>
<p>我们可以使用 time 来查看程序运行花了多少的时间:</p>
<pre><code>$ time php -i &gt;&gt; /dev/null
php -i &gt;&gt; /dev/null  0.06s user 0.01s system 95% cpu 0.074 total
</code></pre>
<p>上面这条命令的含义是我们使用 <code>time</code> 来测试 <code>php -i &gt;&gt; /dev/null</code> 这条命令花了多长的时间，其输出的解释如下:</p>
<pre><code>命令 用户态时间 user 内核态时间 system CPU占用 cpu 总共花费时间 total
</code></pre>
<p>所以，这条命令 CPU 的运算时间是 用户态时间+ 内核态时间，而总共花费的时间减去 CPU 的运算时间是中间等待 CPU 分片的时间。</p>
<h2 id="htop-查看cpu-内存-进程">htop-查看CPU、内存、进程</h2>
<p>在大多数的 Linux 发行版中，都使用 top 来实时查看系统资源，比如 CPU、内存以及进程的相关信息。现在，我们可以使用 htop 来代替 top 这个程序了。使用 htop 更加的简洁易用、直观明了。<br>
可以使用包管理工具来安装 htop, 比如在 CentOS8 下，可以使用 <code>sudo dnf install htop -y</code> 。<br>
然后输入 <code>htop</code> 即可查看系统资源占用情况, 如下图所示:<br>
<img src="https://blog.qianqian.fun/post-images/1599549979877.png" alt="" loading="lazy"><br>
可以按下 <code>F1</code> 来查看帮助，可以使用 <code>q</code> 或者 <code>F10</code> 退出程序。可以使用 <code>F4</code> 过滤进程， 使用 <code>F5</code> 排序，按下 <code>t</code> 可以查看进程的父子层级。按下 <code>u</code> 可以显示所有进程的用户列表，并根据用户列表来过滤进程信息。<br>
更多的用户可以参考帮助信息:<br>
<img src="https://blog.qianqian.fun/post-images/1599550091813.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[压力测试工具ab]]></title>
        <id>https://blog.qianqian.fun/post/ya-li-ce-shi-ab/</id>
        <link href="https://blog.qianqian.fun/post/ya-li-ce-shi-ab/">
        </link>
        <updated>2020-06-27T05:45:57.000Z</updated>
        <content type="html"><![CDATA[<p>首先，我找到一个人的 blog，网址是https://blog.codingnow.com/，我想对这个页面进行压力测试，怎么做？我们使用ab工具来进行测试，centos8 的发行版就自带了这个软件。</p>
<pre><code>ab -n500 https://blog.codingnow.com/
</code></pre>
<p>返回比较慢，我们换一个网址：</p>
<pre><code>ab -n3000 http://165.84.180.25/index.html
</code></pre>
<p><code>-n</code> 是指定我们的请求数，一共请求了 3000 次<br>
<img src="https://blog.qianqian.fun/post-images/1598507506230.png" alt="" loading="lazy"><br>
你看，结果中显示我们的服务器每秒大概可以处理 4961.70 个这样的请求，但是我们这个只是静态页面。<br>
然后我们来测试一下我们之前写的 hello 接口：<br>
<img src="https://blog.qianqian.fun/post-images/1598507943315.png" alt="" loading="lazy"></p>
<pre><code>ab -n1000 http://165.84.180.25/WeChat.Message/hello
</code></pre>
<p><img src="https://blog.qianqian.fun/post-images/1598508112520.png" alt="" loading="lazy"><br>
明显慢了很多<br>
<img src="https://blog.qianqian.fun/post-images/1598508013114.png" alt="" loading="lazy"><br>
每秒只能处理 15.96 个请求<br>
<img src="https://blog.qianqian.fun/post-images/1598508370974.png" alt="" loading="lazy"><br>
应该是这样的结果<br>
<img src="https://blog.qianqian.fun/post-images/1599551466506.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>